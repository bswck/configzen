#!/usr/bin/env python
# (C) bswck
#
# Run this script to release a new version of the package.
#
# Usage:
# $ release [major|minor|patch|<major>.<minor>.<patch>]
"""
Automate the release process by updating local files, creating and pushing a new tag.

The actual release is made via GitHub Actions.
"""

import argparse
import functools
import logging
import subprocess
import sys

_LOGGER = logging.getLogger("release")


if __name__ == "__main__":
    _LOGGER.setLevel(logging.INFO)
    (_LOGGER_HANDLER := logging.StreamHandler()).setFormatter(
        logging.Formatter("%(levelname)s: %(message)s"),
    )
    _LOGGER.addHandler(_LOGGER_HANDLER)

    cmd, shell = str.split, functools.partial(subprocess.run, check=True)

    def abort(msg: str, /) -> None:
        """Display an error message and exit the script process with status code -1."""
        _LOGGER.critical(msg)
        sys.exit(-1)

    parser = argparse.ArgumentParser(description="Release a semver version.")
    parser.add_argument(
        "version",
        type=str,
        nargs=1,
    )
    args: argparse.Namespace = parser.parse_args()
    version: str = args.version.pop()

    files_changed = shell(
        cmd("git diff --name-only HEAD"),
        capture_output=True,
    ).stdout.decode()

    if files_changed:
        msg = (
            "There are uncommitted changes in the working tree in these files:\n"
            f"{files_changed}\n"
            "Continue? They will be included in the release commit. (y/n) [n]: "
        )
        continue_confirm = (input(msg).casefold().strip() or "n")[0]
        if continue_confirm != "y":
            abort("Uncommitted changes in the working tree.")

    # If we get here, we should be good to go
    # Let's do a final check for safety
    msg = f"You are about to release {version!r} version. Are you sure? (y/n) [y]: "

    release_confirm = ((input(msg).casefold().strip()) or "y")[0]

    if release_confirm != "y":
        abort(f"You said no when prompted to bump the {version!r} version.")

    shell(cmd("poetry self add poetry-bumpversion@latest"))

    _LOGGER.info("Bumping the %r version", version)

    shell([*cmd("poetry version"), version])

    new_version = "v" + (
        shell(cmd("poetry version --short"), capture_output=True)
        .stdout.decode()
        .strip()
    )

    files_changed_for_release = shell(
        cmd("git diff --name-only HEAD"),
        capture_output=True,
    ).stdout.decode()

    if files_changed_for_release:
        shell(cmd("git diff"))
        msg = (
            "You are about to commit and push auto-changed files due "
            "to version upgrade, see the diff view above. "
            "Are you sure? (y/n) [y]: "
        )
        commit_confirm = ((input(msg).casefold().strip()) or "y")[0]

        if commit_confirm == "y":
            shell([*cmd("git commit -am"), f"Release {new_version}"])
            shell(cmd("git push"))
        else:
            abort(
                "Changes made uncommitted. "
                "Commit your unrelated changes and try again.",
            )

    _LOGGER.info("Creating %s tag...", new_version)

    try:
        shell([*cmd("git tag -a"), new_version, "-m", f"Release {new_version}"])
    except subprocess.CalledProcessError:
        abort(f"Failed to create {new_version} tag, probably already exists.")
    else:
        _LOGGER.info("Pushing local tags...")
        shell(cmd("git push --tags"))
