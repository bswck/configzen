{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"configzen","text":"<p>Manage configuration with pydantic.</p>"},{"location":"#for-enterprise","title":"For Enterprise","text":"Available as part of the Tidelift Subscription.This project and the maintainers of thousands of other packages are working with Tidelift to deliver one enterprise subscription that covers all of the open source you use. Learn more here. <p>To report a security vulnerability, please use the Tidelift security contact. Tidelift will coordinate the fix and disclosure.</p>"},{"location":"#installation","title":"Installation","text":"<p>You might simply install it with pip:</p> <pre><code>pip install configzen\n</code></pre> <p>If you use Poetry, then you might want to run:</p> <pre><code>poetry add configzen\n</code></pre>"},{"location":"#for-contributors","title":"For Contributors","text":"<p>Note</p> <p>If you use Windows, it is highly recommended to complete the installation in the way presented below through WSL2.</p> <ol> <li> <p>Fork the configzen repository on GitHub.</p> </li> <li> <p>Install Poetry.     Poetry is an amazing tool for managing dependencies &amp; virtual environments, building packages and publishing them.     You might use pipx to install it globally (recommended):</p> <pre><code>pipx install poetry\n</code></pre> <p><sub>If you encounter any problems, refer to the official documentation for the most up-to-date installation instructions.</sub></p> <p>Be sure to have Python 3.8 installed\u2014if you use pyenv, simply run:</p> <pre><code>pyenv install 3.8\n</code></pre> </li> <li> <p>Clone your fork locally and install dependencies.</p> <pre><code>git clone https://github.com/your-username/configzen path/to/configzen\ncd path/to/configzen\npoetry env use $(cat .python-version)\npoetry install\n</code></pre> <p>Next up, simply activate the virtual environment and install pre-commit hooks:</p> <pre><code>poetry shell\npre-commit install\n</code></pre> </li> </ol> <p>For more information on how to contribute, check out CONTRIBUTING.md. Always happy to accept contributions! \u2764\ufe0f</p>"},{"location":"#legal-info","title":"Legal Info","text":"<p>\u00a9 Copyright by Bartosz S\u0142awecki (@bswck). This software is licensed under the terms of GPL-3.0 License.</p>"},{"location":"api/","title":"API Reference","text":"<p>Manage configuration with pydantic.</p> <p>Modules:</p> <ul> <li> <code>config</code>         \u2013          <p>The base configuration model class <code>BaseConfig</code>.</p> </li> <li> <code>context</code>         \u2013          <p>Facilities for contextual processing.</p> </li> <li> <code>contrib</code>         \u2013          <p>configzen.contrib: miscellaneous reusable configuration models from configzen.</p> </li> <li> <code>data</code>         \u2013          <p>Interfaces for encapsulation of configuring and using data formats.</p> </li> <li> <code>errors</code>         \u2013          <p>Specialized exceptions raised by configzen.</p> </li> <li> <code>formats</code>         \u2013          <p><code>configzen.formats</code>: Data formats supported natively by configzen.</p> </li> <li> <code>module_proxy</code>         \u2013          <p>Runtime modules with attribute type validation.</p> </li> <li> <code>processor</code>         \u2013          <p>Replacement API processor for configuration data.</p> </li> <li> <code>routes</code>         \u2013          <p>Routes creation and parsing.</p> </li> <li> <code>sources</code>         \u2013          <p>Sources and destinations that hold the configuration data.</p> </li> <li> <code>typedefs</code>         \u2013          <p>Miscellaneous type definitions for configzen.</p> </li> </ul>"},{"location":"api/#configzen.config","title":"<code>config</code>","text":"<p>The base configuration model class <code>BaseConfig</code>.</p> <p>Classes:</p> <ul> <li> <code>ModelConfig</code>         \u2013          <p>Meta-configuration for configzen models.</p> </li> <li> <code>BaseConfig</code>         \u2013          <p>Base class for all configuration models.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>config_step</code>           \u2013            <p>Return the value of a configuration attribute.</p> </li> </ul>"},{"location":"api/#configzen.config.ModelConfig","title":"<code>ModelConfig</code>","text":"<p>             Bases: <code>SettingsConfigDict</code></p> <p>Meta-configuration for configzen models.</p>"},{"location":"api/#configzen.config.BaseConfig","title":"<code>BaseConfig(**data)</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Base class for all configuration models.</p> <p>Methods:</p> <ul> <li> <code>config_find_routes</code>           \u2013            <p>Locate all occurrences of a subconfiguration in the current configuration.</p> </li> <li> <code>config_find_route</code>           \u2013            <p>Locate exactly one (closest) route to the given subconfiguration.</p> </li> <li> <code>config_load</code>           \u2013            <p>Load this configuration from a given source.</p> </li> <li> <code>config_load_async</code>           \u2013            <p>Do the same as <code>config_load</code>, but asynchronously (no I/O blocking).</p> </li> <li> <code>config_reload</code>           \u2013            <p>Reload the configuration from the same source.</p> </li> <li> <code>config_reload_async</code>           \u2013            <p>Do the same as <code>config_reload</code> asynchronously (no I/O blocking).</p> </li> <li> <code>config_save</code>           \u2013            <p>Save the configuration to a given destination.</p> </li> <li> <code>config_save_async</code>           \u2013            <p>Do the same as <code>config_save</code>, but asynchronously (no I/O blocking).</p> </li> <li> <code>config_at</code>           \u2013            <p>Return a configuration item at the given set of routes.</p> </li> <li> <code>config_dump</code>           \u2013            <p>Return a dictionary representation of the configuration.</p> </li> <li> <code>__getitem__</code>           \u2013            <p>Return a configuration item at the given set of routes.</p> </li> <li> <code>__setitem__</code>           \u2013            <p>Set a configuration item at the given set of routes.</p> </li> <li> <code>__init_subclass__</code>           \u2013            <p>Initialize the configuration subclass.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>config_root</code>             (<code>BaseConfig</code>)         \u2013          <p>Return the root configuration that was used to load the entire data.</p> </li> <li> <code>config_source</code>             (<code>ConfigSource[Any, Any] | None</code>)         \u2013          <p>Return the configuration source that was used to load the configuration.</p> </li> <li> <code>config_data</code>             (<code>Data</code>)         \u2013          <p>Return the configuration that was loaded from the configuration source.</p> </li> <li> <code>config_processor</code>             (<code>ConfigProcessor</code>)         \u2013          <p>Current configuration processor.</p> </li> </ul> Source code in <code>configzen/config.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    try:\n        owner = owner_lookup.get()\n    except LookupError:\n        owner = None\n        if processing.get():\n            owner_lookup.set(self)\n    super().__init__(**data)\n    self._config_root = owner\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_root","title":"<code>config_root: BaseConfig</code>","text":"<p>Return the root configuration that was used to load the entire data.</p>"},{"location":"api/#configzen.config.BaseConfig.config_source","title":"<code>config_source: ConfigSource[Any, Any] | None</code>","text":"<p>Return the configuration source that was used to load the configuration.</p>"},{"location":"api/#configzen.config.BaseConfig.config_data","title":"<code>config_data: Data</code>","text":"<p>Return the configuration that was loaded from the configuration source.</p>"},{"location":"api/#configzen.config.BaseConfig.config_processor","title":"<code>config_processor: ConfigProcessor</code>","text":"<p>Current configuration processor.</p> <p>Processor stores the initial data used when loading the configuration, resolves macros etc.</p>"},{"location":"api/#configzen.config.BaseConfig.config_find_routes","title":"<code>config_find_routes(subconfig)</code>","text":"<p>Locate all occurrences of a subconfiguration in the current configuration.</p> <p>Return a set of routes to the located subconfiguration.</p> Source code in <code>configzen/config.py</code> <pre><code>def config_find_routes(\n    self,\n    subconfig: BaseConfig,\n) -&gt; set[Route]:\n    \"\"\"\n    Locate all occurrences of a subconfiguration in the current configuration.\n\n    Return a set of routes to the located subconfiguration.\n    \"\"\"\n    if not isinstance(subconfig, BaseConfig):\n        msg = f\"Expected a BaseConfig subclass instance, got {type(subconfig)!r}\"\n        raise TypeError(msg)\n    return set(\n        _locate_in_mapping(vars(self), subconfig, attribute_access=True),\n    )\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_find_route","title":"<code>config_find_route(subconfig)</code>","text":"<p>Locate exactly one (closest) route to the given subconfiguration.</p> Source code in <code>configzen/config.py</code> <pre><code>def config_find_route(self, subconfig: BaseConfig) -&gt; Route:\n    \"\"\"Locate exactly one (closest) route to the given subconfiguration.\"\"\"\n    all_routes = self.config_find_routes(subconfig)\n    if not all_routes:\n        msg = f\"Unable to locate subconfiguration {subconfig}\"\n        raise LookupError(msg)\n    return next(iter(all_routes))\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_load","title":"<code>config_load(source=None, *, processor_factory=None)</code>","text":"<p>Load this configuration from a given source.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>self</code>         \u2013          </li> </ul> Source code in <code>configzen/config.py</code> <pre><code>@classmethod\n@isolated_context_function\ndef config_load(\n    cls,\n    source: object | None = None,\n    *,\n    processor_factory: Callable[..., ConfigProcessor] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Load this configuration from a given source.\n\n    Parameters\n    ----------\n    source\n        Where to load the configuration from. The argument passed is forwarded\n        to `confizen.sources.get_config_source()` which will resolve\n        the intended configuration source: for example, \"abc.ini\" will be resolved\n        to a TOML text file source. Keep in mind, however, that for binary formats\n        such as non-XML Plist you must specify its format type to binary, so in\n        that case just create `BinaryFileConfigSource(\"plist_file.plist\")`.\n    processor_factory\n        The state factory to use to parse the newly loaded configuration data.\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    cls._try_rebuild_model()\n\n    # Validate the source we load our configuration from.\n    config_source = cls._validate_config_source(source)\n\n    # Validate the processor we use to parse the loaded configuration data.\n    make_processor = cls._validate_processor_factory(processor_factory)\n\n    # Load the configuration data from the sanitized source.\n    # Keep in mind the loaded data object keeps all the additional\n    # metadata that we want to keep.\n    # Then we pass it to the processor factory to process the configuration data\n    # into a bare dictionary that does not hold anything else\n    # than the configuration data, by using `processor.get_processed_data()`.\n    processor = make_processor(config_source.load())\n\n    # ruff: noqa: FBT003\n    try:\n        processing.set(ProcessingContext(cls, processor, trace=[config_source]))\n\n        # Processing will execute any commands that are present\n        # in the configuration data and return the final configuration\n        # data that we will use to construct an instance of the configuration model.\n        # During this process, we lose all the additional metadata that we\n        # want to keep in the configuration data.\n        # They will be added back to the exported data when the configuration\n        # is saved (`processor.revert_processor_changes()`).\n        self = cls(**processor.get_processed_data())\n    finally:\n        processing.set(None)\n\n    # Quick setup and we're done.\n    self._config_source = config_source\n    self._config_processor = processor\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_load(source)","title":"<code>source</code>","text":"(<code>object | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to load the configuration from. The argument passed is forwarded to <code>confizen.sources.get_config_source()</code> which will resolve the intended configuration source: for example, \"abc.ini\" will be resolved to a TOML text file source. Keep in mind, however, that for binary formats such as non-XML Plist you must specify its format type to binary, so in that case just create <code>BinaryFileConfigSource(\"plist_file.plist\")</code>.</p>"},{"location":"api/#configzen.config.BaseConfig.config_load(processor_factory)","title":"<code>processor_factory</code>","text":"(<code>Callable[..., ConfigProcessor] | None</code>, default:                 <code>None</code> )         \u2013          <p>The state factory to use to parse the newly loaded configuration data.</p>"},{"location":"api/#configzen.config.BaseConfig.config_load_async","title":"<code>config_load_async(source=None, *, processor_factory=None)</code>","text":"<p>Do the same as <code>config_load</code>, but asynchronously (no I/O blocking).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>self</code>         \u2013          </li> </ul> Source code in <code>configzen/config.py</code> <pre><code>@classmethod\n@isolated_context_coroutine\nasync def config_load_async(\n    cls,\n    source: object | None = None,\n    *,\n    processor_factory: Callable[..., ConfigProcessor] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Do the same as `config_load`, but asynchronously (no I/O blocking).\n\n    Parameters\n    ----------\n    source\n        Where to load the configuration from. The argument passed is forwarded\n        to `confizen.sources.get_config_source()` which will resolve\n        the intended configuration source: for example, \"abc.ini\" will be resolved\n        to a TOML text file source. Keep in mind, however, that for binary formats\n        such as non-XML Plist you must specify its format type to binary, so in\n        that case just create `BinaryFileConfig\"plist_file.plist\")`.\n    processor_factory\n        The state factory to use to parse the newly loaded configuration data.\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    cls._try_rebuild_model()\n\n    # Intentionally not using `run_sync(config_load)` here.\n    # We want to keep make the set up instructions blocking to avoid running\n    # into mutexes.\n\n    config_source = cls._validate_config_source(source)\n    make_processor = cls._validate_processor_factory(processor_factory)\n    processor = make_processor(await config_source.load_async())\n\n    try:\n        processing.set(ProcessingContext(cls, processor, trace=[config_source]))\n\n        self = cls(**await run_sync(processor.get_processed_data))\n    finally:\n        processing.set(None)\n\n    self._config_processor = processor\n    self._config_source = config_source\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_load_async(source)","title":"<code>source</code>","text":"(<code>object | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to load the configuration from. The argument passed is forwarded to <code>confizen.sources.get_config_source()</code> which will resolve the intended configuration source: for example, \"abc.ini\" will be resolved to a TOML text file source. Keep in mind, however, that for binary formats such as non-XML Plist you must specify its format type to binary, so in that case just create <code>BinaryFileConfig\"plist_file.plist\")</code>.</p>"},{"location":"api/#configzen.config.BaseConfig.config_load_async(processor_factory)","title":"<code>processor_factory</code>","text":"(<code>Callable[..., ConfigProcessor] | None</code>, default:                 <code>None</code> )         \u2013          <p>The state factory to use to parse the newly loaded configuration data.</p>"},{"location":"api/#configzen.config.BaseConfig.config_reload","title":"<code>config_reload()</code>","text":"<p>Reload the configuration from the same source.</p> Source code in <code>configzen/config.py</code> <pre><code>def config_reload(self) -&gt; Self:\n    \"\"\"Reload the configuration from the same source.\"\"\"\n    source = self.config_source\n\n    if source is None:\n        msg = \"Cannot reload a manually instantiated configuration\"\n        raise RuntimeError(msg)\n\n    root = self.config_root\n\n    # Create a new processor with the same options as the current one.\n    processor = root.config_processor.create_processor(source.load())\n\n    # Construct a new configuration instance.\n    # Respect __class__ attribute in case root might be a proxy (from proxyvars).\n    new_root = root.__class__(**processor.get_processed_data())\n\n    # Copy values from the freshly loaded configuration into our instance.\n    if root is self:\n        new_data = new_root.config_dump()\n    else:\n        route_to_self = root.config_find_route(self)\n        new_data = cast(\"Self\", route_to_self.get(new_root)).config_dump()\n\n    for key, value in new_data.items():\n        setattr(self, key, value)\n\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_reload_async","title":"<code>config_reload_async()</code>","text":"<p>Do the same as <code>config_reload</code> asynchronously (no I/O blocking).</p> Source code in <code>configzen/config.py</code> <pre><code>async def config_reload_async(self) -&gt; Self:\n    \"\"\"Do the same as `config_reload` asynchronously (no I/O blocking).\"\"\"\n    source = self.config_source\n\n    if source is None:\n        msg = \"Cannot reload a manually instantiated configuration\"\n        raise RuntimeError(msg)\n\n    root = self.config_root\n\n    # Create a new state processor the same options as the current one.\n    processor = root.config_processor.create_processor(source.load())\n\n    # Construct a new configuration instance.\n    new_root = root.__class__(**await run_sync(processor.get_processed_data))\n\n    # Copy values from the freshly loaded configuration into our instance.\n    if root is self:\n        new_data = new_root.config_dump()\n    else:\n        route_to_self = root.config_find_route(self)\n        new_data = cast(\"Self\", route_to_self.get(new_root)).config_dump()\n\n    for key, value in new_data.items():\n        setattr(self, key, value)\n\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_save","title":"<code>config_save(destination=None)</code>","text":"<p>Save the configuration to a given destination.</p> <p>Parameters:</p> Source code in <code>configzen/config.py</code> <pre><code>def config_save(self, destination: object | None = None) -&gt; Self:\n    \"\"\"\n    Save the configuration to a given destination.\n\n    Parameters\n    ----------\n    destination\n        Where to save the configuration to. The argument passed is forwarded\n        to `confizen.sources.get_config_source()` which will resolve\n        the intended configuration source: for example, \"abc.ini\" will be resolved\n        to a TOML text file source. Keep in mind, however, that for binary formats\n        such as non-XML Plist you must specify its format type to binary, so in\n        that case just create `BinaryFileConfigSource(\"plist_file.plist\")`.\n\n    \"\"\"\n    config_destination, data = self._config_data_save(destination)\n    config_destination.dump(data)\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_save(destination)","title":"<code>destination</code>","text":"(<code>object | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to save the configuration to. The argument passed is forwarded to <code>confizen.sources.get_config_source()</code> which will resolve the intended configuration source: for example, \"abc.ini\" will be resolved to a TOML text file source. Keep in mind, however, that for binary formats such as non-XML Plist you must specify its format type to binary, so in that case just create <code>BinaryFileConfigSource(\"plist_file.plist\")</code>.</p>"},{"location":"api/#configzen.config.BaseConfig.config_save_async","title":"<code>config_save_async(destination=None)</code>","text":"<p>Do the same as <code>config_save</code>, but asynchronously (no I/O blocking).</p> <p>Parameters:</p> Source code in <code>configzen/config.py</code> <pre><code>async def config_save_async(self, destination: object | None = None) -&gt; Self:\n    \"\"\"\n    Do the same as `config_save`, but asynchronously (no I/O blocking).\n\n    Parameters\n    ----------\n    destination\n        Where to save the configuration to. The argument passed is forwarded\n        to `confizen.sources.get_config_source()` which will resolve\n        the intended configuration source: for example, \"abc.ini\" will be resolved\n        to a TOML text file source. Keep in mind, however, that for binary formats\n        such as non-XML Plist you must specify its format type to binary, so in\n        that case just create `BinaryFileConfigSource(\"plist_file.plist\")`.\n\n    \"\"\"\n    config_destination, data = self._config_data_save(destination)\n    await config_destination.dump_async(data)\n    return self\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_save_async(destination)","title":"<code>destination</code>","text":"(<code>object | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to save the configuration to. The argument passed is forwarded to <code>confizen.sources.get_config_source()</code> which will resolve the intended configuration source: for example, \"abc.ini\" will be resolved to a TOML text file source. Keep in mind, however, that for binary formats such as non-XML Plist you must specify its format type to binary, so in that case just create <code>BinaryFileConfigSource(\"plist_file.plist\")</code>.</p>"},{"location":"api/#configzen.config.BaseConfig.config_at","title":"<code>config_at(*routes)</code>","text":"<p>Return a configuration item at the given set of routes.</p> Source code in <code>configzen/config.py</code> <pre><code>def config_at(self, *routes: RouteLike) -&gt; Item:\n    \"\"\"Return a configuration item at the given set of routes.\"\"\"\n    return Item(routes=set(map(Route, routes)), config=self)\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.config_dump","title":"<code>config_dump()</code>","text":"<p>Return a dictionary representation of the configuration.</p> Source code in <code>configzen/config.py</code> <pre><code>def config_dump(self) -&gt; dict[str, object]:\n    \"\"\"Return a dictionary representation of the configuration.\"\"\"\n    return super().model_dump()\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.__getitem__","title":"<code>__getitem__(routes)</code>","text":"<p>Return a configuration item at the given set of routes.</p> Source code in <code>configzen/config.py</code> <pre><code>def __getitem__(self, routes: RouteLike | tuple[RouteLike, ...]) -&gt; Item:\n    \"\"\"Return a configuration item at the given set of routes.\"\"\"\n    if isinstance(routes, tuple):\n        return self.config_at(*routes)\n    return self.config_at(routes)\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.__setitem__","title":"<code>__setitem__(item, value)</code>","text":"<p>Set a configuration item at the given set of routes.</p> Source code in <code>configzen/config.py</code> <pre><code>def __setitem__(self, item: RouteLike, value: Any) -&gt; None:\n    \"\"\"Set a configuration item at the given set of routes.\"\"\"\n    self.config_at(item).config = value\n</code></pre>"},{"location":"api/#configzen.config.BaseConfig.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Initialize the configuration subclass.</p> Source code in <code>configzen/config.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Unpack[ModelConfig]) -&gt; None:\n    \"\"\"Initialize the configuration subclass.\"\"\"\n    super().__init_subclass__(**cast(\"BaseConfigDict\", kwargs))\n</code></pre>"},{"location":"api/#configzen.config.config_step","title":"<code>config_step(owner, _annotation, step)</code>","text":"<p>Return the value of a configuration attribute.</p> Source code in <code>configzen/config.py</code> <pre><code>@advance_linked_route.register(BaseConfig)\ndef config_step(\n    owner: type[BaseConfig],\n    _annotation: Any,\n    step: Step[Any],\n) -&gt; Any:\n    \"\"\"Return the value of a configuration attribute.\"\"\"\n    return owner.model_fields[step.key].annotation\n</code></pre>"},{"location":"api/#configzen.context","title":"<code>context</code>","text":"<p>Facilities for contextual processing.</p> <p>Functions:</p> <ul> <li> <code>isolated_context_function</code>           \u2013            <p>Copy the context automatically on function call.</p> </li> <li> <code>isolated_context_coroutine</code>           \u2013            <p>Copy the context automatically on coroutine execution.</p> </li> <li> <code>run_isolated</code>           \u2013            <p>Run a function in an isolated context.</p> </li> <li> <code>async_run_isolated</code>           \u2013            <p>Await a coroutine in an isolated context.</p> </li> </ul>"},{"location":"api/#configzen.context.isolated_context_function","title":"<code>isolated_context_function(func)</code>","text":"<p>Copy the context automatically on function call.</p> <p>Allows to isolate the library context from the user context.</p> <p>Used as a decorator.</p> Source code in <code>configzen/context.py</code> <pre><code>def isolated_context_function(func: Callable[_P, _T]) -&gt; Callable[_P, _T]:\n    \"\"\"\n    Copy the context automatically on function call.\n\n    Allows to isolate the library context from the user context.\n\n    Used as a decorator.\n    \"\"\"\n    if isinstance(func, (classmethod, staticmethod)):\n        return type(func)(isolated_context_function(func.__func__))\n\n    @wraps(func)\n    def copy(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n        return run_isolated(func, *args, **kwargs)\n\n    return copy\n</code></pre>"},{"location":"api/#configzen.context.isolated_context_coroutine","title":"<code>isolated_context_coroutine(func)</code>","text":"<p>Copy the context automatically on coroutine execution.</p> <p>Allows to isolate library context from the user context.</p> <p>Used as a decorator.</p> Source code in <code>configzen/context.py</code> <pre><code>def isolated_context_coroutine(\n    func: Callable[_P, Coroutine[object, object, _T]],\n) -&gt; Callable[_P, Coroutine[object, object, _T]]:\n    \"\"\"\n    Copy the context automatically on coroutine execution.\n\n    Allows to isolate library context from the user context.\n\n    Used as a decorator.\n    \"\"\"\n    if isinstance(func, (classmethod, staticmethod)):\n        return type(func)(isolated_context_coroutine(func.__func__))\n\n    @wraps(func)\n    async def copy_async(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n        return await async_run_isolated(func, *args, **kwargs)\n\n    return copy_async\n</code></pre>"},{"location":"api/#configzen.context.run_isolated","title":"<code>run_isolated(func, *args, **kwargs)</code>","text":"<p>Run a function in an isolated context.</p> Source code in <code>configzen/context.py</code> <pre><code>def run_isolated(func: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n    \"\"\"Run a function in an isolated context.\"\"\"\n    context = contextvars.copy_context()\n    return context.run(func, *args, **kwargs)\n</code></pre>"},{"location":"api/#configzen.context.async_run_isolated","title":"<code>async_run_isolated(func, *args, **kwargs)</code>","text":"<p>Await a coroutine in an isolated context.</p> Source code in <code>configzen/context.py</code> <pre><code>def async_run_isolated(\n    func: Callable[_P, Coroutine[object, object, _T]],\n    *args: _P.args,\n    **kwargs: _P.kwargs,\n) -&gt; asyncio.Task[_T]:\n    \"\"\"Await a coroutine in an isolated context.\"\"\"\n    return asyncio.create_task(func(*args, **kwargs))\n</code></pre>"},{"location":"api/#configzen.contrib","title":"<code>contrib</code>","text":"<p>configzen.contrib: miscellaneous reusable configuration models from configzen.</p> <p>Modules:</p> <ul> <li> <code>pyproject</code>         \u2013          <p>Configuration model for <code>pyproject.toml</code> files.</p> </li> <li> <code>setup</code>         \u2013          <p>Configuration model for <code>pyproject.toml</code> files.</p> </li> </ul>"},{"location":"api/#configzen.contrib.pyproject","title":"<code>pyproject</code>","text":"<p>Configuration model for <code>pyproject.toml</code> files.</p>"},{"location":"api/#configzen.contrib.setup","title":"<code>setup</code>","text":"<p>Configuration model for <code>pyproject.toml</code> files.</p>"},{"location":"api/#configzen.data","title":"<code>data</code>","text":"<p>Interfaces for encapsulation of configuring and using data formats.</p> <p>Classes:</p> <ul> <li> <code>DataFormatOptions</code>         \u2013          <p>Base class for indicating possible options to configure a data format.</p> </li> <li> <code>DataFormat</code>         \u2013          <p>Core interface for configuring and using any data format through within configzen.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>roundtrip_update_mapping</code>           \u2013            <p>Update a mapping without losing recursively attached metadata.</p> </li> <li> <code>roundtrip_update_sequence</code>           \u2013            <p>Update a sequence without losing recursively attached metadata.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>BinaryDataFormat</code>         \u2013          <p>Core interface for configuring and using binary data formats through</p> </li> <li> <code>TextDataFormat</code>         \u2013          <p>Core interface for configuring and using text data formats through</p> </li> </ul>"},{"location":"api/#configzen.data.BinaryDataFormat","title":"<code>BinaryDataFormat = DataFormat[DataFormatOptionsType, bytes]</code>","text":"<p>Core interface for configuring and using binary data formats through within configzen.</p> <p>Do not use this class directly. If you need to implement your own binary data format, implement a subclass of this class. Remember to ensure that your subclass is executed, so that it gets registered to the registry of data formats.</p>"},{"location":"api/#configzen.data.TextDataFormat","title":"<code>TextDataFormat = DataFormat[DataFormatOptionsType, str]</code>","text":"<p>Core interface for configuring and using text data formats through within configzen.</p> <p>Do not use this class directly. If you need to implement your own text data format, implement a subclass of this class. Remember to ensure that your subclass is executed, so that it gets registered to the registry of data formats.</p>"},{"location":"api/#configzen.data.DataFormatOptions","title":"<code>DataFormatOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Base class for indicating possible options to configure a data format.</p>"},{"location":"api/#configzen.data.DataFormat","title":"<code>DataFormat(options=None)</code>","text":"<p>             Bases: <code>Generic[DataFormatOptionsType, AnyStr]</code></p> <p>Core interface for configuring and using any data format through within configzen.</p> <p>Do not use this class directly. If you need to implement your own data format, implement a subclass of: - BinaryDataFormat, if it is a bitwise data format, or - TextDataFormat, if it is a text data format.</p> <p>Methods:</p> <ul> <li> <code>for_extension</code>           \u2013            <p>Create a data format instance for an extension.</p> </li> <li> <code>is_binary</code>           \u2013            <p>Return whether the data format is bitwise.</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the data format.</p> </li> <li> <code>load</code>           \u2013            <p>Load the data from a stream.</p> </li> <li> <code>dump</code>           \u2013            <p>Load the data from a stream.</p> </li> <li> <code>register_file_extensions</code>           \u2013            <p>Register the file extensions supported by this data format.</p> </li> <li> <code>validate_source</code>           \u2013            <p>Validate the config source.</p> </li> <li> <code>roundtrip_update_mapping</code>           \u2013            <p>Update the loaded data in a round-trip manner.</p> </li> <li> <code>roundtrip_update_sequence</code>           \u2013            <p>Merge new data sequence without losing comments.</p> </li> <li> <code>__init_subclass__</code>           \u2013            <p>Subclass hook. Pass skip_hook=True to skip it.</p> </li> </ul> Source code in <code>configzen/data.py</code> <pre><code>def __init__(self, options: DataFormatOptionsType | None = None) -&gt; None:\n    self.configure(**(options or {}))\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.for_extension","title":"<code>for_extension(extension_name, options=None)</code>","text":"<p>Create a data format instance for an extension.</p> Source code in <code>configzen/data.py</code> <pre><code>@classmethod\ndef for_extension(\n    cls,\n    extension_name: str,\n    options: DataFormatOptionsType | None = None,\n) -&gt; DataFormat[Any, Any]:\n    \"\"\"Create a data format instance for an extension.\"\"\"\n    return cls.extension_registry[extension_name](options)\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.is_binary","title":"<code>is_binary()</code>","text":"<pre><code>is_binary() -&gt; Literal[True]\n</code></pre><pre><code>is_binary() -&gt; Literal[False]\n</code></pre> <p>Return whether the data format is bitwise.</p> Source code in <code>configzen/data.py</code> <pre><code>def is_binary(self) -&gt; bool:\n    \"\"\"Return whether the data format is bitwise.\"\"\"\n    return type_check(self, DataFormat[Any, bytes])\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.configure","title":"<code>configure(**options)</code>","text":"<p>Configure the data format.</p> <p>Every data format provides its own options, related to comments, indentation, and other format-specific features.</p> Source code in <code>configzen/data.py</code> <pre><code>def configure(self, **options: Unpack[DataFormatOptions]) -&gt; None:\n    \"\"\"\n    Configure the data format.\n\n    Every data format provides its own options, related to comments, indentation,\n    and other format-specific features.\n    \"\"\"\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.load","title":"<code>load(stream)</code>","text":"<p>Load the data from a stream.</p> <p>Return a mutable mapping representing the loaded data which is mutation-sensitive (for round-trip processing).</p> <p>Every configuration source transforms the input data into a stream to be processed by the data format, because most data format libraries operate on streams.</p> <p>This method is called by the config instance.</p> Source code in <code>configzen/data.py</code> <pre><code>@abstractmethod\ndef load(self, stream: IO[AnyStr]) -&gt; Data:\n    \"\"\"\n    Load the data from a stream.\n\n    Return a mutable mapping representing the loaded data\n    which is mutation-sensitive (for round-trip processing).\n\n    Every configuration source transforms the input data into a stream\n    to be processed by the data format, because most data format libraries\n    operate on streams.\n\n    This method is called by the config instance.\n    \"\"\"\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.dump","title":"<code>dump(data, stream)</code>","text":"<p>Load the data from a stream.</p> <p>Every configuration source transforms the input data into a stream to be processed by the data format, because most libraries implementing data formats operate on streams.</p> <p>This method is called by the config instance.</p> Source code in <code>configzen/data.py</code> <pre><code>@abstractmethod\ndef dump(self, data: Data, stream: IO[AnyStr]) -&gt; None:\n    \"\"\"\n    Load the data from a stream.\n\n    Every configuration source transforms the input data into a stream\n    to be processed by the data format, because most libraries implementing\n    data formats operate on streams.\n\n    This method is called by the config instance.\n    \"\"\"\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.register_file_extensions","title":"<code>register_file_extensions()</code>","text":"<p>Register the file extensions supported by this data format.</p> Source code in <code>configzen/data.py</code> <pre><code>@classmethod\ndef register_file_extensions(cls) -&gt; None:\n    \"\"\"Register the file extensions supported by this data format.\"\"\"\n    cls.extension_registry.update(dict.fromkeys(cls.file_extensions, cls))\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.validate_source","title":"<code>validate_source(source)</code>","text":"<p>Validate the config source.</p> Source code in <code>configzen/data.py</code> <pre><code>def validate_source(self, source: ConfigSource[Any, AnyStr]) -&gt; None:\n    \"\"\"Validate the config source.\"\"\"\n    if self.is_binary() and not source.is_binary():\n        msg = (\n            f\"{source} is not a binary source, \"\n            f\"but {self.__class__.__name__} is a binary data format\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.roundtrip_update_mapping","title":"<code>roundtrip_update_mapping(roundtrip_data, mergeable_data)</code>","text":"<p>Update the loaded data in a round-trip manner.</p> <p>Use values from the configuration altered programmatically in runtime, while keeping the structure and comments of the original data.</p> <p>Parameters:</p> Source code in <code>configzen/data.py</code> <pre><code>def roundtrip_update_mapping(\n    self,\n    roundtrip_data: Data,\n    mergeable_data: MutableMapping[str, object],\n) -&gt; None:\n    \"\"\"\n    Update the loaded data in a round-trip manner.\n\n    Use values from the configuration altered programmatically in runtime,\n    while keeping the structure and comments of the original data.\n\n    Parameters\n    ----------\n    roundtrip_data\n        The data to be updated. Stores the original structure, comments etc.\n    mergeable_data\n        The new values to be merged into the loaded data.\n\n    \"\"\"\n    return roundtrip_update_mapping(\n        roundtrip_data,\n        mergeable_data,\n        _recursive_update_mapping=self.roundtrip_update_mapping,\n        _recursive_update_sequence=self.roundtrip_update_sequence,\n    )\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.roundtrip_update_mapping(roundtrip_data)","title":"<code>roundtrip_data</code>","text":"(<code>Data</code>)         \u2013          <p>The data to be updated. Stores the original structure, comments etc.</p>"},{"location":"api/#configzen.data.DataFormat.roundtrip_update_mapping(mergeable_data)","title":"<code>mergeable_data</code>","text":"(<code>MutableMapping[str, object]</code>)         \u2013          <p>The new values to be merged into the loaded data.</p>"},{"location":"api/#configzen.data.DataFormat.roundtrip_update_sequence","title":"<code>roundtrip_update_sequence(roundtrip_data, mergeable_data)</code>","text":"<p>Merge new data sequence without losing comments.</p> Source code in <code>configzen/data.py</code> <pre><code>def roundtrip_update_sequence(\n    self,\n    roundtrip_data: MutableSequence[object],\n    mergeable_data: Sequence[object],\n) -&gt; None:\n    \"\"\"Merge new data sequence without losing comments.\"\"\"\n    return roundtrip_update_sequence(\n        roundtrip_data,\n        mergeable_data,\n        _recursive_update_mapping=self.roundtrip_update_mapping,\n        _recursive_update_sequence=self.roundtrip_update_sequence,\n    )\n</code></pre>"},{"location":"api/#configzen.data.DataFormat.__init_subclass__","title":"<code>__init_subclass__(*, skip_hook=False)</code>","text":"<p>Subclass hook. Pass skip_hook=True to skip it.</p> Source code in <code>configzen/data.py</code> <pre><code>def __init_subclass__(cls, *, skip_hook: bool = False) -&gt; None:\n    \"\"\"Subclass hook. Pass skip_hook=True to skip it.\"\"\"\n    if not skip_hook:\n        if getattr(cls, \"option_name\", None) is None:\n            msg = (\n                f\"{cls.__name__} must have an option_name attribute \"\n                \"if it is not a class with skip_hook=True parameter\"\n            )\n            raise TypeError(msg)\n        if getattr(cls, \"file_extensions\", None) is None:\n            cls.file_extensions = set()\n        cls.file_extensions.add(cls.default_extension)\n        cls.register_file_extensions()\n</code></pre>"},{"location":"api/#configzen.data.roundtrip_update_mapping","title":"<code>roundtrip_update_mapping(roundtrip_data, mergeable_data, *, _recursive_update_mapping=None, _recursive_update_sequence=None)</code>","text":"<p>Update a mapping without losing recursively attached metadata.</p> Source code in <code>configzen/data.py</code> <pre><code>def roundtrip_update_mapping(\n    roundtrip_data: Data,\n    mergeable_data: MutableMapping[str, object],\n    *,\n    _recursive_update_mapping: Callable[[Data, MutableMapping[str, object]], None]\n    | None = None,\n    _recursive_update_sequence: Callable[\n        [MutableSequence[object], Sequence[object]],\n        None,\n    ]\n    | None = None,\n) -&gt; None:\n    \"\"\"Update a mapping without losing recursively attached metadata.\"\"\"\n    if _recursive_update_mapping is None:\n        _recursive_update_mapping = partial(\n            roundtrip_update_mapping,\n            _recursive_update_sequence=_recursive_update_sequence,\n        )\n    if _recursive_update_sequence is None:\n        _recursive_update_sequence = partial(\n            roundtrip_update_sequence,\n            _recursive_update_mapping=_recursive_update_mapping,\n        )\n    for key, value in roundtrip_data.items():\n        if key in mergeable_data:\n            new_value = mergeable_data.pop(key)\n            if isinstance(value, MutableMapping):\n                # Coerce it's a dict to ensure it has the .pop() method\n                _recursive_update_mapping(\n                    value,\n                    dict(cast(\"Mapping[str, object]\", new_value)),\n                )\n            elif isinstance(value, MutableSequence):\n                _recursive_update_sequence(\n                    value,\n                    cast(\"MutableSequence[object]\", new_value),\n                )\n            else:\n                roundtrip_data[key] = new_value\n    for key, value in mergeable_data.items():\n        roundtrip_data[key] = value\n</code></pre>"},{"location":"api/#configzen.data.roundtrip_update_sequence","title":"<code>roundtrip_update_sequence(roundtrip_data, mergeable_data, *, _recursive_update_mapping=None, _recursive_update_sequence=None)</code>","text":"<p>Update a sequence without losing recursively attached metadata.</p> Source code in <code>configzen/data.py</code> <pre><code>def roundtrip_update_sequence(\n    roundtrip_data: MutableSequence[object],\n    mergeable_data: Sequence[object],\n    *,\n    _recursive_update_mapping: Callable[[Data, MutableMapping[str, object]], None]\n    | None = None,\n    _recursive_update_sequence: Callable[\n        [MutableSequence[object], Sequence[object]],\n        None,\n    ]\n    | None = None,\n) -&gt; None:\n    \"\"\"Update a sequence without losing recursively attached metadata.\"\"\"\n    if _recursive_update_mapping is None:\n        _recursive_update_mapping = partial(\n            roundtrip_update_mapping,\n            _recursive_update_sequence=_recursive_update_sequence,\n        )\n    if _recursive_update_sequence is None:\n        _recursive_update_sequence = partial(\n            roundtrip_update_sequence,\n            _recursive_update_mapping=_recursive_update_mapping,\n        )\n    sequence_length = len(mergeable_data)\n    for i, (roundtrip_item, mergeable_item) in enumerate(\n        zip_longest(\n            roundtrip_data,\n            mergeable_data,\n        ),\n    ):\n        if i &gt;= sequence_length:\n            roundtrip_data[i] = roundtrip_item\n        elif isinstance(roundtrip_item, MutableMapping):\n            _recursive_update_mapping(\n                roundtrip_item,\n                dict(cast(\"Mapping[str, object]\", mergeable_item)),\n            )\n        elif isinstance(roundtrip_item, MutableSequence):\n            _recursive_update_sequence(\n                roundtrip_item,\n                cast(\"list[object]\", mergeable_item),\n            )\n</code></pre>"},{"location":"api/#configzen.errors","title":"<code>errors</code>","text":"<p>Specialized exceptions raised by configzen.</p> <p>Classes:</p> <ul> <li> <code>ConfigError</code>         \u2013          <p>Base class for all errors related to configzen.</p> </li> <li> <code>ConfigLoadError</code>         \u2013          <p>Raised when the configuration cannot be loaded.</p> </li> <li> <code>ConfigReloadError</code>         \u2013          <p>Raised when the configuration cannot be reloaded.</p> </li> <li> <code>ConfigSaveError</code>         \u2013          <p>Raised when the configuration cannot be saved.</p> </li> <li> <code>NotAMappingError</code>         \u2013          <p>Raised when the configuration being loaded is not a mapping.</p> </li> <li> <code>ConfigProcessorError</code>         \u2013          <p>Raised when a configuration replacement processor error occurs.</p> </li> <li> <code>BaseRouteError</code>         \u2013          <p>Raised when a configuration item route is invalid.</p> </li> <li> <code>RouteError</code>         \u2013          <p>Raised when a configuration item route is invalid at a specific index.</p> </li> <li> <code>LinkedRouteError</code>         \u2013          <p>Raised when a declared configuration item route is invalid.</p> </li> </ul>"},{"location":"api/#configzen.errors.ConfigError","title":"<code>ConfigError(message)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all errors related to configzen.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.ConfigLoadError","title":"<code>ConfigLoadError(message)</code>","text":"<p>             Bases: <code>ConfigError</code></p> <p>Raised when the configuration cannot be loaded.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.ConfigReloadError","title":"<code>ConfigReloadError(message)</code>","text":"<p>             Bases: <code>ConfigLoadError</code></p> <p>Raised when the configuration cannot be reloaded.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.ConfigSaveError","title":"<code>ConfigSaveError(message)</code>","text":"<p>             Bases: <code>ConfigError</code></p> <p>Raised when the configuration cannot be saved.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.NotAMappingError","title":"<code>NotAMappingError(message)</code>","text":"<p>             Bases: <code>ConfigLoadError</code>, <code>TypeError</code></p> <p>Raised when the configuration being loaded is not a mapping.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.ConfigProcessorError","title":"<code>ConfigProcessorError(message)</code>","text":"<p>             Bases: <code>ConfigError</code></p> <p>Raised when a configuration replacement processor error occurs.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.BaseRouteError","title":"<code>BaseRouteError(message)</code>","text":"<p>             Bases: <code>ConfigError</code>, <code>ValueError</code></p> <p>Raised when a configuration item route is invalid.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/#configzen.errors.RouteError","title":"<code>RouteError(message, route, index)</code>","text":"<p>             Bases: <code>BaseRouteError</code></p> <p>Raised when a configuration item route is invalid at a specific index.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>           \u2013            <p>Return a string representation of the route error.</p> </li> </ul> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(self, message: str, route: str, index: int) -&gt; None:\n    self.message = message\n    self.route = route\n    self.index = index\n</code></pre>"},{"location":"api/#configzen.errors.RouteError.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the route error.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the route error.\"\"\"\n    return f\"{self.message} ({self.route}:{self.index})\"\n</code></pre>"},{"location":"api/#configzen.errors.LinkedRouteError","title":"<code>LinkedRouteError(message, route, config_class)</code>","text":"<p>             Bases: <code>BaseRouteError</code></p> <p>Raised when a declared configuration item route is invalid.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>           \u2013            <p>Return a string representation of the route error.</p> </li> </ul> Source code in <code>configzen/errors.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    route: str,\n    config_class: type[BaseConfig],\n) -&gt; None:\n    self.message = message\n    self.route = route\n    self.config_class = config_class\n</code></pre>"},{"location":"api/#configzen.errors.LinkedRouteError.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the route error.</p> Source code in <code>configzen/errors.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the route error.\"\"\"\n    return f\"{self.message} ({self.config_class.__name__}.{self.route})\"\n</code></pre>"},{"location":"api/#configzen.formats","title":"<code>formats</code>","text":"<p><code>configzen.formats</code>: Data formats supported natively by configzen.</p> <p>Modules:</p> <ul> <li> <code>std_json</code>         \u2013          <p><code>configzen.formats.std_json</code>: The JSON data format.</p> </li> <li> <code>std_plist</code>         \u2013          <p><code>configzen.formats.std_plist</code>: The Plist data format.</p> </li> <li> <code>toml</code>         \u2013          <p><code>configzen.formats.toml</code>: The TOML data format.</p> </li> <li> <code>yaml</code>         \u2013          <p><code>configzen.formats.yaml</code>: The YAML data format.</p> </li> </ul>"},{"location":"api/#configzen.formats.std_json","title":"<code>std_json</code>","text":"<p><code>configzen.formats.std_json</code>: The JSON data format.</p> <p>Classes:</p> <ul> <li> <code>JSONOptions</code>         \u2013          <p>Prototype of the allowed options for the JSON data format.</p> </li> <li> <code>JSONDataFormat</code>         \u2013          <p>The JSON data format.</p> </li> </ul>"},{"location":"api/#configzen.formats.std_json.JSONOptions","title":"<code>JSONOptions</code>","text":"<p>             Bases: <code>DataFormatOptions</code></p> <p>Prototype of the allowed options for the JSON data format.</p>"},{"location":"api/#configzen.formats.std_json.JSONDataFormat","title":"<code>JSONDataFormat</code>","text":"<p>             Bases: <code>TextDataFormat[JSONOptions]</code></p> <p>The JSON data format.</p> <p>Methods:</p> <ul> <li> <code>configure</code>           \u2013            <p>For the documentation of the options, see the JSONOptions class.</p> </li> <li> <code>load</code>           \u2013            <p>Load the JSON data from the given stream.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the given JSON data to the given stream.</p> </li> </ul>"},{"location":"api/#configzen.formats.std_json.JSONDataFormat.configure","title":"<code>configure(**options)</code>","text":"<p>For the documentation of the options, see the JSONOptions class.</p> Source code in <code>configzen/formats/std_json.py</code> <pre><code>def configure(self, **options: Unpack[JSONOptions]) -&gt; None:\n    \"\"\"For the documentation of the options, see the JSONOptions class.\"\"\"\n    self.json_encoder = JSONEncoder(\n        skipkeys=options.get(\"skipkeys\") or self.json_encoder.skipkeys,\n        ensure_ascii=options.get(\"ensure_ascii\") or self.json_encoder.ensure_ascii,\n        check_circular=options.get(\"check_circular\")\n        or self.json_encoder.check_circular,\n        allow_nan=options.get(\"allow_nan\") or self.json_encoder.allow_nan,\n        indent=options.get(\"indent\") or self.json_encoder.indent,\n        separators=options.get(\"separators\")\n        or (\n            self.json_encoder.item_separator,\n            self.json_encoder.key_separator,\n        ),\n        default=options.get(\"default\") or self.json_encoder.default,\n    )\n    self.json_decoder = JSONDecoder(\n        object_hook=options.get(\"object_hook\") or self.json_decoder.object_hook,\n        parse_float=options.get(\"parse_float\") or self.json_decoder.parse_float,\n        parse_int=options.get(\"parse_int\") or self.json_decoder.parse_int,\n        parse_constant=options.get(\"parse_constant\")\n        or self.json_decoder.parse_constant,\n        strict=options.get(\"strict\") or self.json_decoder.strict,\n        object_pairs_hook=options.get(\"object_pairs_hook\")\n        or self.json_decoder.object_pairs_hook,\n    )\n</code></pre>"},{"location":"api/#configzen.formats.std_json.JSONDataFormat.load","title":"<code>load(stream)</code>","text":"<p>Load the JSON data from the given stream.</p> Source code in <code>configzen/formats/std_json.py</code> <pre><code>def load(self, stream: IO[str]) -&gt; Data:\n    \"\"\"Load the JSON data from the given stream.\"\"\"\n    document = (\n        load(\n            stream,\n            cls=cast(\"type[JSONDecoder]\", lambda **_: self.json_decoder),\n        )\n        or {}\n    )\n    if not isinstance(document, dict):\n        msg = (\n            f\"Expected a dict mapping, \"\n            f\"but got {type(document).__name__} instead.\"\n        )\n        raise TypeError(msg)\n    return document\n</code></pre>"},{"location":"api/#configzen.formats.std_json.JSONDataFormat.dump","title":"<code>dump(data, stream)</code>","text":"<p>Dump the given JSON data to the given stream.</p> Source code in <code>configzen/formats/std_json.py</code> <pre><code>def dump(self, data: Data, stream: IO[str]) -&gt; None:\n    \"\"\"Dump the given JSON data to the given stream.\"\"\"\n    dump(\n        data,\n        stream,\n        cls=cast(\"type[JSONEncoder]\", lambda **_: self.json_encoder),\n    )\n</code></pre>"},{"location":"api/#configzen.formats.std_plist","title":"<code>std_plist</code>","text":"<p><code>configzen.formats.std_plist</code>: The Plist data format.</p> <p>Classes:</p> <ul> <li> <code>PlistOptions</code>         \u2013          <p>Prototype of the allowed options for the Plist data format.</p> </li> <li> <code>PlistDataFormat</code>         \u2013          <p>The Plist data format.</p> </li> </ul>"},{"location":"api/#configzen.formats.std_plist.PlistOptions","title":"<code>PlistOptions</code>","text":"<p>             Bases: <code>DataFormatOptions</code></p> <p>Prototype of the allowed options for the Plist data format.</p>"},{"location":"api/#configzen.formats.std_plist.PlistDataFormat","title":"<code>PlistDataFormat</code>","text":"<p>             Bases: <code>BinaryDataFormat[PlistOptions]</code></p> <p>The Plist data format.</p> <p>Methods:</p> <ul> <li> <code>configure</code>           \u2013            <p>For the documentation of the options, see the PlistOptions class.</p> </li> <li> <code>load</code>           \u2013            <p>Load the data from the given stream.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the given data to the stream.</p> </li> </ul>"},{"location":"api/#configzen.formats.std_plist.PlistDataFormat.configure","title":"<code>configure(**options)</code>","text":"<p>For the documentation of the options, see the PlistOptions class.</p> Source code in <code>configzen/formats/std_plist.py</code> <pre><code>def configure(self, **options: Unpack[PlistOptions]) -&gt; None:\n    \"\"\"For the documentation of the options, see the PlistOptions class.\"\"\"\n    if \"fmt\" not in options:\n        options[\"fmt\"] = self.plist_options.get(\"fmt\", PlistFormat.FMT_XML)\n    if \"dict_type\" not in options:\n        options[\"dict_type\"] = self.plist_options.get(\n            \"dict_type\",\n            dict,\n        )  # type: ignore[typeddict-item]\n    if \"sort_keys\" not in options:\n        # configzen focuses on preserving the original structure,\n        # so we don't sort by default.\n        options[\"sort_keys\"] = self.plist_options.get(\"sort_keys\", False)\n    if \"skipkeys\" not in options:\n        options[\"skipkeys\"] = self.plist_options.get(\"skipkeys\", False)\n    self.plist_options = options\n</code></pre>"},{"location":"api/#configzen.formats.std_plist.PlistDataFormat.load","title":"<code>load(stream)</code>","text":"<p>Load the data from the given stream.</p> Source code in <code>configzen/formats/std_plist.py</code> <pre><code>def load(self, stream: IO[bytes]) -&gt; Data:\n    \"\"\"Load the data from the given stream.\"\"\"\n    dict_class: type[MutableMapping[str, Any]] = self.plist_options[\"dict_type\"]\n    document = (\n        load(\n            stream,\n            fmt=self.plist_options[\"fmt\"],\n            dict_type=dict_class,\n        )\n        or dict_class()\n    )\n    if not isinstance(document, dict_class):\n        msg = (\n            f\"Expected a {dict_class.__name__} mapping, \"\n            f\"but got {type(document).__name__} instead.\"\n        )\n        raise TypeError(msg)\n    return document\n</code></pre>"},{"location":"api/#configzen.formats.std_plist.PlistDataFormat.dump","title":"<code>dump(data, stream)</code>","text":"<p>Dump the given data to the stream.</p> Source code in <code>configzen/formats/std_plist.py</code> <pre><code>def dump(self, data: Data, stream: IO[bytes]) -&gt; None:\n    \"\"\"Dump the given data to the stream.\"\"\"\n    dump(\n        data,\n        stream,\n        fmt=self.plist_options[\"fmt\"],\n        sort_keys=self.plist_options[\"sort_keys\"],\n        skipkeys=self.plist_options[\"skipkeys\"],\n    )\n</code></pre>"},{"location":"api/#configzen.formats.toml","title":"<code>toml</code>","text":"<p><code>configzen.formats.toml</code>: The TOML data format.</p> <p>Classes:</p> <ul> <li> <code>TOMLOptions</code>         \u2013          <p>Prototype of the allowed options for the TOML data format.</p> </li> <li> <code>TOMLDataFormat</code>         \u2013          <p>The TOML data format.</p> </li> </ul>"},{"location":"api/#configzen.formats.toml.TOMLOptions","title":"<code>TOMLOptions</code>","text":"<p>             Bases: <code>DataFormatOptions</code></p> <p>Prototype of the allowed options for the TOML data format.</p> <p>Attributes:</p> <ul> <li> <code>encoders</code>             (<code>list[Encoder]</code>)         \u2013          <p>List of encoders to perform automatic tomlkit.register_encoder() calls on.</p> </li> <li> <code>unregister_old_encoders</code>             (<code>bool</code>)         \u2013          <p>Whether to unregister all previously registered encoders</p> </li> <li> <code>sort_keys</code>             (<code>bool</code>)         \u2013          <p>Whether to sort keys in the output.</p> </li> </ul>"},{"location":"api/#configzen.formats.toml.TOMLOptions.encoders","title":"<code>encoders: list[Encoder]</code>","text":"<p>List of encoders to perform automatic tomlkit.register_encoder() calls on.</p>"},{"location":"api/#configzen.formats.toml.TOMLOptions.unregister_old_encoders","title":"<code>unregister_old_encoders: bool</code>","text":"<p>Whether to unregister all previously registered encoders before registering the new ones.</p>"},{"location":"api/#configzen.formats.toml.TOMLOptions.sort_keys","title":"<code>sort_keys: bool</code>","text":"<p>Whether to sort keys in the output.</p>"},{"location":"api/#configzen.formats.toml.TOMLDataFormat","title":"<code>TOMLDataFormat</code>","text":"<p>             Bases: <code>TextDataFormat[TOMLOptions]</code></p> <p>The TOML data format.</p> <p>Methods:</p> <ul> <li> <code>configure</code>           \u2013            <p>For the documentation of the options, see the TOMLOptions class.</p> </li> <li> <code>load</code>           \u2013            <p>Load the data from the given stream.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the data to the given stream.</p> </li> </ul>"},{"location":"api/#configzen.formats.toml.TOMLDataFormat.configure","title":"<code>configure(**options)</code>","text":"<p>For the documentation of the options, see the TOMLOptions class.</p> Source code in <code>configzen/formats/toml.py</code> <pre><code>def configure(self, **options: Unpack[TOMLOptions]) -&gt; None:\n    \"\"\"For the documentation of the options, see the TOMLOptions class.\"\"\"\n    old_options = self.toml_options\n    toml_encoders = options.get(\"encoders\") or old_options.get(\"encoders\") or []\n    cleanup_old_encoders = options.get(\"cleanup_old_encoders\", False)\n\n    if cleanup_old_encoders:\n        for encoder in self.toml_options.get(\"encoders\") or []:\n            unregister_encoder(encoder)\n\n    for encoder in toml_encoders:\n        register_encoder(encoder)\n</code></pre>"},{"location":"api/#configzen.formats.toml.TOMLDataFormat.load","title":"<code>load(stream)</code>","text":"<p>Load the data from the given stream.</p> Source code in <code>configzen/formats/toml.py</code> <pre><code>def load(self, stream: IO[str]) -&gt; Data:\n    \"\"\"Load the data from the given stream.\"\"\"\n    return load(stream)\n</code></pre>"},{"location":"api/#configzen.formats.toml.TOMLDataFormat.dump","title":"<code>dump(data, stream)</code>","text":"<p>Dump the data to the given stream.</p> Source code in <code>configzen/formats/toml.py</code> <pre><code>def dump(self, data: Data, stream: IO[str]) -&gt; None:\n    \"\"\"Dump the data to the given stream.\"\"\"\n    dump(\n        data,\n        stream,\n        sort_keys=self.toml_options.get(\"sort_keys\", False),\n    )\n</code></pre>"},{"location":"api/#configzen.formats.yaml","title":"<code>yaml</code>","text":"<p><code>configzen.formats.yaml</code>: The YAML data format.</p> <p>Classes:</p> <ul> <li> <code>YAMLOptions</code>         \u2013          <p>Prototype of the allowed options for the YAML data format.</p> </li> <li> <code>YAMLDataFormat</code>         \u2013          <p>The YAML data format.</p> </li> </ul>"},{"location":"api/#configzen.formats.yaml.YAMLOptions","title":"<code>YAMLOptions</code>","text":"<p>             Bases: <code>DataFormatOptions</code></p> <p>Prototype of the allowed options for the YAML data format.</p> <p>For more information, see the documentation of the <code>ruamel.yaml.YAML</code> class.</p> <p>Attributes:</p> <ul> <li> <code>classes</code>             (<code>list[type]</code>)         \u2013          <p>List of classes to automatically call YAML.register_class() on.</p> </li> <li> <code>version</code>             (<code>str | tuple[int | str, ...]</code>)         \u2013          <p>The YAML version to use.</p> </li> <li> <code>indent</code>             (<code>int</code>)         \u2013          <p>Indentation width.</p> </li> <li> <code>block_seq_indent</code>             (<code>int</code>)         \u2013          <p>Indentation for nested block sequences.</p> </li> </ul>"},{"location":"api/#configzen.formats.yaml.YAMLOptions.classes","title":"<code>classes: list[type]</code>","text":"<p>List of classes to automatically call YAML.register_class() on.</p>"},{"location":"api/#configzen.formats.yaml.YAMLOptions.version","title":"<code>version: str | tuple[int | str, ...]</code>","text":"<p>The YAML version to use.</p>"},{"location":"api/#configzen.formats.yaml.YAMLOptions.indent","title":"<code>indent: int</code>","text":"<p>Indentation width.</p>"},{"location":"api/#configzen.formats.yaml.YAMLOptions.block_seq_indent","title":"<code>block_seq_indent: int</code>","text":"<p>Indentation for nested block sequences.</p>"},{"location":"api/#configzen.formats.yaml.YAMLDataFormat","title":"<code>YAMLDataFormat</code>","text":"<p>             Bases: <code>TextDataFormat[YAMLOptions]</code></p> <p>The YAML data format.</p> <p>Methods:</p> <ul> <li> <code>configure</code>           \u2013            <p>For the documentation of the options, see the YAMLOptions class.</p> </li> <li> <code>load</code>           \u2013            <p>Load the data from a stream.</p> </li> <li> <code>dump</code>           \u2013            <p>Load the data from a stream.</p> </li> </ul>"},{"location":"api/#configzen.formats.yaml.YAMLDataFormat.configure","title":"<code>configure(**options)</code>","text":"<p>For the documentation of the options, see the YAMLOptions class.</p> Source code in <code>configzen/formats/yaml.py</code> <pre><code>def configure(self, **options: Unpack[YAMLOptions]) -&gt; None:\n    \"\"\"For the documentation of the options, see the YAMLOptions class.\"\"\"\n    yaml_classes = options.pop(\"classes\", None) or []\n\n    old_yaml = self.yaml\n    yaml_version = options.pop(\"version\", None) or old_yaml.version\n    yaml_indent = options.pop(\"indent\", None) or old_yaml.old_indent\n    yaml_block_seq_indent = (\n        options.pop(\"block_seq_indent\", None) or old_yaml.block_seq_indent\n    )\n\n    yaml = YAML(**options)  # type: ignore[arg-type,misc]\n    yaml.version = yaml_version  # type: ignore[assignment]\n    yaml.indent = yaml_indent\n    yaml.block_seq_indent = yaml_block_seq_indent\n\n    for cls in yaml_classes:\n        yaml.register_class(cls)\n\n    self.yaml = yaml\n</code></pre>"},{"location":"api/#configzen.formats.yaml.YAMLDataFormat.load","title":"<code>load(stream)</code>","text":"<p>Load the data from a stream.</p> <p>Return a mutable mapping representing the loaded data which is mutation-sensitive (for round-trip processing).</p> <p>Every configuration source transforms the input data into a stream to be processed by the data format, because most data format libraries operate on streams.</p> <p>This method is called by the configuration model.</p> Source code in <code>configzen/formats/yaml.py</code> <pre><code>def load(self, stream: IO[str]) -&gt; Data:\n    \"\"\"\n    Load the data from a stream.\n\n    Return a mutable mapping representing the loaded data\n    which is mutation-sensitive (for round-trip processing).\n\n    Every configuration source transforms the input data into a stream\n    to be processed by the data format, because most data format libraries\n    operate on streams.\n\n    This method is called by the configuration model.\n    \"\"\"\n    data = self.yaml.load(stream) or CommentedMap()\n    if not isinstance(data, dict):\n        msg = f\"Expected a dict, but got {type(data).__name__}.\"\n        raise TypeError(msg)\n    return data\n</code></pre>"},{"location":"api/#configzen.formats.yaml.YAMLDataFormat.dump","title":"<code>dump(data, stream)</code>","text":"<p>Load the data from a stream.</p> <p>Every configuration source transforms the input data into a stream to be processed by the data format, because most data format libraries operate on streams.</p> <p>This method is called by the configuration model.</p> Source code in <code>configzen/formats/yaml.py</code> <pre><code>def dump(self, data: Data, stream: IO[str]) -&gt; None:\n    \"\"\"\n    Load the data from a stream.\n\n    Every configuration source transforms the input data into a stream\n    to be processed by the data format, because most data format libraries\n    operate on streams.\n\n    This method is called by the configuration model.\n    \"\"\"\n    self.yaml.dump(data, stream)\n</code></pre>"},{"location":"api/#configzen.module_proxy","title":"<code>module_proxy</code>","text":"<p>Runtime modules with attribute type validation.</p> <p>Classes:</p> <ul> <li> <code>ModuleProxy</code>         \u2013          <p>Proxy object that extends a runtime module with type validation.</p> </li> </ul>"},{"location":"api/#configzen.module_proxy.ModuleProxy","title":"<code>ModuleProxy(name, config, module_namespace=None, doc=None)</code>","text":"<p>             Bases: <code>ModuleType</code>, <code>Generic[ConfigObject]</code></p> <p>Proxy object that extends a runtime module with type validation.</p> <p>Triggered via a config instance (initialization and assignment).</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__getattribute__</code>           \u2013            <p>Get an attribute of the underlying model.</p> </li> <li> <code>__setattr__</code>           \u2013            <p>Set an attribute on the underlying model.</p> </li> <li> <code>__repr__</code>           \u2013            <p>Get the string representation of the module proxy.</p> </li> <li> <code>get_config</code>           \u2013            <p>Get the configuration model.</p> </li> <li> <code>wrap_module</code>           \u2013            <p>Wrap a module to ensure type validation.</p> </li> <li> <code>wrap_this_module</code>           \u2013            <p>Wrap the module calling this function.</p> </li> </ul> Source code in <code>configzen/module_proxy.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    config: ConfigObject,\n    module_namespace: dict[str, Any] | None = None,\n    doc: str | None = None,\n) -&gt; None:\n    object.__setattr__(self, \"__config__\", config)\n    object.__setattr__(self, \"__locals__\", module_namespace or {})\n    object.__setattr__(config, \"__wrapped_module__\", self)\n\n    super().__init__(name=name, doc=doc)\n\n    parts = name.split(\".\")\n    if len(parts) &gt; 1:\n        # Set the proxy module as an attribute of its parent.\n        parent = sys.modules[\".\".join(parts[:-1])]\n        setattr(parent, parts[-1], self)\n\n    # Make reusable.\n    sys.modules[name] = self\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy(name)","title":"<code>name</code>","text":"(<code>str</code>)         \u2013          <p>The name of the module.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy(config)","title":"<code>config</code>","text":"(<code>ConfigObject</code>)         \u2013          <p>The configuration model to use for type validation.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy(module_namespace)","title":"<code>module_namespace</code>","text":"(<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The module namespace to wrap.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"<p>Get an attribute of the underlying model.</p> Source code in <code>configzen/module_proxy.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    \"\"\"Get an attribute of the underlying model.\"\"\"\n    if _is_dunder(name):\n        return object.__getattribute__(self, name)\n\n    config = self.__config__\n    try:\n        return getattr(config, name)\n    except AttributeError:\n        try:\n            return self.__locals__[name]\n        except KeyError:\n            return object.__getattribute__(self, name)\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Set an attribute on the underlying model.</p> Source code in <code>configzen/module_proxy.py</code> <pre><code>def __setattr__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute on the underlying model.\"\"\"\n    config = self.get_config()\n    if not _is_dunder(key) and key in config.model_fields:\n        setattr(config, key, value)\n    self.__locals__[key] = value\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.__repr__","title":"<code>__repr__()</code>","text":"<p>Get the string representation of the module proxy.</p> <p>Inform the user that this is a configuration module.</p> Source code in <code>configzen/module_proxy.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get the string representation of the module proxy.\n\n    Inform the user that this is a configuration module.\n    \"\"\"\n    return super().__repr__().replace(\"module\", \"configuration module\", 1)\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.get_config","title":"<code>get_config()</code>","text":"<p>Get the configuration model.</p> Source code in <code>configzen/module_proxy.py</code> <pre><code>def get_config(self) -&gt; ConfigObject:\n    \"\"\"Get the configuration model.\"\"\"\n    return self.__config__\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_module","title":"<code>wrap_module(module_name, config_class=None, namespace=None, /, **values)</code>","text":"<p>Wrap a module to ensure type validation.</p> <p>Every attribute of the wrapped module that is also a field of the config will be validated against it. The module will be extended with the config's attributes. Assignments on the module's attributes will be propagated to the configuration instance. It could be said that the module becomes a proxy for the configuration once wrapped.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>The wrapped module.</code>         \u2013          </li> </ul> Source code in <code>configzen/module_proxy.py</code> <pre><code>@classmethod\ndef wrap_module(\n    cls,\n    module_name: str,\n    config_class: type[ConfigObject] | None = None,\n    namespace: dict[str, Any] | None = None,\n    /,\n    **values: Any,\n) -&gt; ModuleProxy[ConfigObject]:\n    \"\"\"\n    Wrap a module to ensure type validation.\n\n    Every attribute of the wrapped module that is also a field of the config will be\n    validated against it. The module will be extended with the config's attributes.\n    Assignments on the module's attributes will be propagated to the configuration\n    instance. It could be said that the module becomes a proxy for the configuration\n    once wrapped.\n\n    Parameters\n    ----------\n    module_name\n        The name of the module to wrap.\n    config_class\n        The config class to use for type validation.\n    namespace\n        The namespace of the module to wrap. If not provided, it will be\n        retrieved from `sys.modules`.\n    values\n        Values used to initialize the config.\n\n    Returns\n    -------\n    The wrapped module.\n\n    \"\"\"\n    from configzen.config import BaseConfig\n\n    if namespace is None:\n        module_namespace = vars(sys.modules[module_name])\n    else:\n        module_namespace = namespace\n\n    if config_class is None:\n\n        class ConfigModule(BaseConfig):\n            __module__ = module_name\n            __annotations__ = module_namespace[\"__annotations__\"]\n            for key in __annotations__:\n                locals()[key] = module_namespace[key]\n\n        config_class = cast(\"type[ConfigObject]\", ConfigModule)\n\n    module_values = {}\n    field_names = frozenset(\n        field_info.validation_alias\n        or field_info.alias\n        or field_info.title\n        or field_name\n        for field_name, field_info in config_class.model_fields.items()\n    )\n    for key, value in module_namespace.items():\n        if key in field_names:\n            module_values[key] = value\n    config = config_class.model_validate({**module_values, **values})\n\n    return cls(\n        config=config,\n        module_namespace=module_namespace,\n        name=module_namespace.get(\"__name__\") or module_name,\n        doc=module_namespace.get(\"__doc__\"),\n    )\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_module(module_name)","title":"<code>module_name</code>","text":"(<code>str</code>)         \u2013          <p>The name of the module to wrap.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_module(config_class)","title":"<code>config_class</code>","text":"(<code>type[ConfigObject] | None</code>, default:                 <code>None</code> )         \u2013          <p>The config class to use for type validation.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_module(namespace)","title":"<code>namespace</code>","text":"(<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The namespace of the module to wrap. If not provided, it will be retrieved from <code>sys.modules</code>.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_module(values)","title":"<code>values</code>","text":"(<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Values used to initialize the config.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_this_module","title":"<code>wrap_this_module(config_class=None, /, **values)</code>","text":"<p>Wrap the module calling this function.</p> <p>For more information on wrapping modules, see <code>ModuleProxy.wrap_module()</code>.</p> <p>Parameters:</p> Source code in <code>configzen/module_proxy.py</code> <pre><code>@classmethod\ndef wrap_this_module(\n    cls,\n    config_class: type[ConfigObject] | None = None,\n    /,\n    **values: Any,\n) -&gt; ModuleProxy[ConfigObject]:\n    \"\"\"\n    Wrap the module calling this function.\n\n    For more information on wrapping modules, see `ModuleProxy.wrap_module()`.\n\n    Parameters\n    ----------\n    config_class\n        The config class to use for type validation.\n    values\n        Values used to initialize the config.\n\n    \"\"\"\n    current_frame = inspect.currentframe()\n    if current_frame is None:\n        msg = \"Could not get the current frame\"\n        raise RuntimeError(msg)\n    frame_back = current_frame.f_back\n    if frame_back is None:\n        msg = \"Could not get the frame back\"\n        raise RuntimeError(msg)\n    return cls.wrap_module(\n        {**frame_back.f_globals, **frame_back.f_locals}[\"__name__\"],\n        config_class,\n        {**frame_back.f_locals, **values},\n    )\n</code></pre>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_this_module(config_class)","title":"<code>config_class</code>","text":"(<code>type[ConfigObject] | None</code>, default:                 <code>None</code> )         \u2013          <p>The config class to use for type validation.</p>"},{"location":"api/#configzen.module_proxy.ModuleProxy.wrap_this_module(values)","title":"<code>values</code>","text":"(<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Values used to initialize the config.</p>"},{"location":"api/#configzen.processor","title":"<code>processor</code>","text":"<p>Replacement API processor for configuration data.</p> <p>Allows to tweak the configuration data programmatically before it is given to the model config and revert the changes back to the original data structure when the configuration managed by that model is saved.</p> <p>Classes:</p> <ul> <li> <code>ProcessorOptions</code>         \u2013          <p>Prototype of the allowed options for the ConfigProcessor class.</p> </li> <li> <code>ConfigProcessor</code>         \u2013          <p>A class that takes in configuration data and processes it.</p> </li> <li> <code>ProcessorReplacement</code>         \u2013          <p>A change that was made to the configuration data during processing.</p> </li> <li> <code>FileSystemAwareConfigProcessor</code>         \u2013          <p>Config processor that is aware of the file system.</p> </li> </ul>"},{"location":"api/#configzen.processor.ProcessorOptions","title":"<code>ProcessorOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Prototype of the allowed options for the ConfigProcessor class.</p>"},{"location":"api/#configzen.processor.ConfigProcessor","title":"<code>ConfigProcessor(initial, *, macro_prefix=Char('^'), update_prefix=Char('+'), macros_on_top=False, lenient=True)</code>","text":"<p>A class that takes in configuration data and processes it.</p> <p>Recursively resolves &amp; applies replacements in data magically.</p> <p>Methods:</p> <ul> <li> <code>create_processor</code>           \u2013            <p>Create a new configuration processor with identical options.</p> </li> <li> <code>get_processed_data</code>           \u2013            <p>Create the data with replacements or return the one already cached.</p> </li> <li> <code>__init_subclass__</code>           \u2013            <p>Merge macro registries on subclass.</p> </li> <li> <code>sanitize_macro_name</code>           \u2013            <p>Ensure a uniform name of every macro.</p> </li> <li> <code>macro</code>           \u2013            <p>Override a macro.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>macros</code>             (<code>MacroDict</code>)         \u2013          <p>Get macros bound to this processor.</p> </li> <li> <code>roundtrip_initial</code>             (<code>Data</code>)         \u2013          <p>The initial configuration data that the processor was given.</p> </li> </ul> Source code in <code>configzen/processor.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    initial: Data,\n    *,\n    macro_prefix: Char = Char(\"^\"),  # noqa: B008\n    update_prefix: Char = Char(\"+\"),  # noqa: B008\n    macros_on_top: bool = False,\n    lenient: bool = True,\n) -&gt; None:\n    self.__initial = initial\n    self.__data: _ProcessedData = None  # type: ignore[assignment]\n\n    self.options = ProcessorOptions(\n        macro_prefix=macro_prefix,\n        update_prefix=update_prefix,\n        macros_on_top=macros_on_top,\n        lenient=lenient,\n    )\n</code></pre>"},{"location":"api/#configzen.processor.ConfigProcessor.macros","title":"<code>macros: MacroDict</code>","text":"<p>Get macros bound to this processor.</p>"},{"location":"api/#configzen.processor.ConfigProcessor.roundtrip_initial","title":"<code>roundtrip_initial: Data</code>","text":"<p>The initial configuration data that the processor was given.</p>"},{"location":"api/#configzen.processor.ConfigProcessor.create_processor","title":"<code>create_processor(data)</code>","text":"<p>Create a new configuration processor with identical options.</p> Source code in <code>configzen/processor.py</code> <pre><code>def create_processor(self, data: Data) -&gt; ConfigProcessor:\n    \"\"\"Create a new configuration processor with identical options.\"\"\"\n    return type(self)(data, **self.options)\n</code></pre>"},{"location":"api/#configzen.processor.ConfigProcessor.get_processed_data","title":"<code>get_processed_data(*, force=False)</code>","text":"<p>Create the data with replacements or return the one already cached.</p> <p>Parameters:</p> Source code in <code>configzen/processor.py</code> <pre><code>def get_processed_data(\n    self,\n    *,\n    force: bool = False,\n) -&gt; _ProcessedData:\n    \"\"\"\n    Create the data with replacements or return the one already cached.\n\n    Parameters\n    ----------\n    force\n        Whether to forcibly parse the original data even if it was already parsed.\n        Default is False.\n\n    \"\"\"\n    if force or self.__data is None:\n        self.__data = self._get_processed_data(\n            data=self.__initial,\n            options=self.options,\n            macros=self.macros,\n        )\n    return self.__data\n</code></pre>"},{"location":"api/#configzen.processor.ConfigProcessor.get_processed_data(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to forcibly parse the original data even if it was already parsed. Default is False.</p>"},{"location":"api/#configzen.processor.ConfigProcessor.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Merge macro registries on subclass.</p> Source code in <code>configzen/processor.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    \"\"\"Merge macro registries on subclass.\"\"\"\n    macros_from_class_dict = {\n        macro_name: func\n        for func in vars(cls).values()\n        if (macro_name := getattr(func, MACRO_FUNC, None))\n    }\n    try:\n        macros = {**getattr(cls.__base__, \"_macros\", {}), **macros_from_class_dict}\n    except AttributeError:\n        macros = {}\n    cls._macros = macros\n</code></pre>"},{"location":"api/#configzen.processor.ConfigProcessor.sanitize_macro_name","title":"<code>sanitize_macro_name(name)</code>","text":"<p>Ensure a uniform name of every macro.</p> Source code in <code>configzen/processor.py</code> <pre><code>@staticmethod\ndef sanitize_macro_name(name: str) -&gt; str:\n    \"\"\"Ensure a uniform name of every macro.\"\"\"\n    return name.strip().casefold()\n</code></pre>"},{"location":"api/#configzen.processor.ConfigProcessor.macro","title":"<code>macro(name, macro)</code>","text":"<p>Override a macro.</p> Source code in <code>configzen/processor.py</code> <pre><code>@classmethod\ndef macro(cls, name: str, macro: MacroT) -&gt; MacroT:\n    \"\"\"Override a macro.\"\"\"\n    name = cls.sanitize_macro_name(name)\n    cls._macros[name] = macro\n    return macro\n</code></pre>"},{"location":"api/#configzen.processor.ProcessorReplacement","title":"<code>ProcessorReplacement(key, value, content)</code>","text":"<p>A change that was made to the configuration data during processing.</p> <p>Attributes:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>The key of the item before alteration.</p> </li> <li> <code>value</code>             (<code>object</code>)         \u2013          <p>The value of the item before alteration.</p> </li> <li> <code>content</code>             (<code>Data</code>)         \u2013          <p>The value to unpack in place of the alteration key.</p> </li> </ul>"},{"location":"api/#configzen.processor.FileSystemAwareConfigProcessor","title":"<code>FileSystemAwareConfigProcessor(initial, *, macro_prefix=Char('^'), update_prefix=Char('+'), macros_on_top=False, lenient=True)</code>","text":"<p>             Bases: <code>ConfigProcessor</code></p> <p>Config processor that is aware of the file system.</p> <p>Can handle requests for transcluding other configuration files to achieve a sense of extendability.</p> <p>Methods:</p> <ul> <li> <code>extend</code>           \u2013            <p>Transclude a config in this config.</p> </li> </ul> Source code in <code>configzen/processor.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    initial: Data,\n    *,\n    macro_prefix: Char = Char(\"^\"),  # noqa: B008\n    update_prefix: Char = Char(\"+\"),  # noqa: B008\n    macros_on_top: bool = False,\n    lenient: bool = True,\n) -&gt; None:\n    self.__initial = initial\n    self.__data: _ProcessedData = None  # type: ignore[assignment]\n\n    self.options = ProcessorOptions(\n        macro_prefix=macro_prefix,\n        update_prefix=update_prefix,\n        macros_on_top=macros_on_top,\n        lenient=lenient,\n    )\n</code></pre>"},{"location":"api/#configzen.processor.FileSystemAwareConfigProcessor.extend","title":"<code>extend(sources)</code>","text":"<p>Transclude a config in this config.</p> Source code in <code>configzen/processor.py</code> <pre><code>@macro\ndef extend(self, sources: str | dict[str, str]) -&gt; Data:\n    \"\"\"Transclude a config in this config.\"\"\"\n    if isinstance(sources, str):\n        source = get_config_source(sources)\n        return source.load()\n    return {\n        key: get_config_source(source).load() for key, source in sources.items()\n    }\n</code></pre>"},{"location":"api/#configzen.routes","title":"<code>routes</code>","text":"<p>Routes creation and parsing.</p> <p>Classes:</p> <ul> <li> <code>Step</code>         \u2013          <p>A configuration route step.</p> </li> <li> <code>GetAttr</code>         \u2013          <p>A route step that gets an attribute from an object.</p> </li> <li> <code>GetItem</code>         \u2013          <p>A route step that gets an item from an object.</p> </li> <li> <code>Route</code>         \u2013          <p>Routes are, lists of steps that are used to access values in a configuration.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>advance_linked_route</code>           \u2013            <p>Move one step forward in a linked route.</p> </li> </ul>"},{"location":"api/#configzen.routes.Step","title":"<code>Step(key)</code>","text":"<p>             Bases: <code>Generic[_KT]</code></p> <p>A configuration route step.</p> <p>Do not use this class directly. Use GetAttr or GetItem instead.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>           \u2013            <p>Compare this step to another step.</p> </li> <li> <code>get</code>           \u2013            <p>Perform a get operation.</p> </li> <li> <code>set</code>           \u2013            <p>Perform a set operation.</p> </li> <li> <code>__call__</code>           \u2013            <p>Perform a get operation.</p> </li> <li> <code>__repr__</code>           \u2013            <p>Represent this step in a string.</p> </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def __init__(self, key: _KT, /) -&gt; None:\n    self.key = key\n</code></pre>"},{"location":"api/#configzen.routes.Step.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare this step to another step.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Compare this step to another step.\"\"\"\n    if isinstance(other, Step):\n        return (\n            issubclass(type(other), type(self))\n            or issubclass(type(self), type(other))\n        ) or self.key == other.key\n    return NotImplemented\n</code></pre>"},{"location":"api/#configzen.routes.Step.get","title":"<code>get(_)</code>","text":"<p>Perform a get operation.</p> Source code in <code>configzen/routes.py</code> <pre><code>def get(self, _: Any, /) -&gt; object:\n    \"\"\"Perform a get operation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.routes.Step.set","title":"<code>set(_, __)</code>","text":"<p>Perform a set operation.</p> Source code in <code>configzen/routes.py</code> <pre><code>def set(self, _: Any, __: object, /) -&gt; None:\n    \"\"\"Perform a set operation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.routes.Step.__call__","title":"<code>__call__(obj)</code>","text":"<p>Perform a get operation.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __call__(self, obj: Any, /) -&gt; object:\n    \"\"\"Perform a get operation.\"\"\"\n    return self.get(obj)\n</code></pre>"},{"location":"api/#configzen.routes.Step.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent this step in a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Represent this step in a string.\"\"\"\n    return f\"{type(self).__name__}({self.key!r})\"\n</code></pre>"},{"location":"api/#configzen.routes.GetAttr","title":"<code>GetAttr(key)</code>","text":"<p>             Bases: <code>Step[str]</code></p> <p>A route step that gets an attribute from an object.</p> <p>The argument is used as an attribute name.</p> <p>Methods:</p> <ul> <li> <code>get</code>           \u2013            <p>Get an attribute from an object.</p> </li> <li> <code>set</code>           \u2013            <p>Set an attribute in an object.</p> </li> <li> <code>__str__</code>           \u2013            <p>Compose this step into a string.</p> </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def __init__(self, key: _KT, /) -&gt; None:\n    self.key = key\n</code></pre>"},{"location":"api/#configzen.routes.GetAttr.get","title":"<code>get(target)</code>","text":"<p>Get an attribute from an object.</p> Source code in <code>configzen/routes.py</code> <pre><code>def get(self, target: Any, /) -&gt; object:\n    \"\"\"Get an attribute from an object.\"\"\"\n    return getattr(target, self.key)\n</code></pre>"},{"location":"api/#configzen.routes.GetAttr.set","title":"<code>set(target, value)</code>","text":"<p>Set an attribute in an object.</p> Source code in <code>configzen/routes.py</code> <pre><code>def set(self, target: Any, value: object, /) -&gt; None:\n    \"\"\"Set an attribute in an object.\"\"\"\n    setattr(target, self.key, value)\n</code></pre>"},{"location":"api/#configzen.routes.GetAttr.__str__","title":"<code>__str__()</code>","text":"<p>Compose this step into a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Compose this step into a string.\"\"\"\n    return str(self.key).replace(Route.TOKEN_DOT, r\"\\.\")\n</code></pre>"},{"location":"api/#configzen.routes.GetItem","title":"<code>GetItem(key, /, *, ignore_digit=False)</code>","text":"<p>             Bases: <code>Step[Union[int, str]]</code></p> <p>A route step that gets an item from an object.</p> <p>If the argument is a string, it is used checked for being a digit. Unless explicitly escaped, if it is a digit, it is casted to an integer. Otherwise, it is used as is.</p> <p>Methods:</p> <ul> <li> <code>get</code>           \u2013            <p>Get an item from an object.</p> </li> <li> <code>set</code>           \u2013            <p>Set an item in an object.</p> </li> <li> <code>__str__</code>           \u2013            <p>Compose this step into a string.</p> </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def __init__(self, key: int | str, /, *, ignore_digit: bool = False) -&gt; None:\n    self.escape = False\n    if isinstance(key, str) and key.isdigit():\n        if ignore_digit:\n            self.escape = True\n        else:\n            key = int(key)\n    super().__init__(key)\n</code></pre>"},{"location":"api/#configzen.routes.GetItem.get","title":"<code>get(target)</code>","text":"<p>Get an item from an object.</p> Source code in <code>configzen/routes.py</code> <pre><code>def get(self, target: Any, /) -&gt; object:\n    \"\"\"Get an item from an object.\"\"\"\n    return target[self.key]\n</code></pre>"},{"location":"api/#configzen.routes.GetItem.set","title":"<code>set(target, value)</code>","text":"<p>Set an item in an object.</p> Source code in <code>configzen/routes.py</code> <pre><code>def set(self, target: Any, value: object, /) -&gt; None:\n    \"\"\"Set an item in an object.\"\"\"\n    target[self.key] = value\n</code></pre>"},{"location":"api/#configzen.routes.GetItem.__str__","title":"<code>__str__()</code>","text":"<p>Compose this step into a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Compose this step into a string.\"\"\"\n    argument = str(self.key)\n    if self.escape:\n        argument = Route.TOKEN_ESCAPE + argument\n    return argument.join(\n        Route.TOKEN_ENTER + Route.TOKEN_LEAVE,\n    ).replace(Route.TOKEN_DOT, r\"\\.\")\n</code></pre>"},{"location":"api/#configzen.routes.Route","title":"<code>Route(route, *, allow_empty=False)</code>","text":"<p>Routes are, lists of steps that are used to access values in a configuration.</p> <p>Each step is either a key or an index.</p> <p>A route can be created from a string, a list of steps, or another route.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; route = Route(\"a.b.c\")\n&gt;&gt;&gt; route\n&lt;Route 'a.b.c'&gt;\n&gt;&gt;&gt; route.steps\n[GetAttr('a'), GetAttr('b'), GetAttr('c')]\n</code></pre> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__hash__</code>           \u2013            <p>Get a hash of this route.</p> </li> <li> <code>parse</code>           \u2013            <p>Parse a route into steps.</p> </li> <li> <code>decompose</code>           \u2013            <p>Decompose a route into a list of steps.</p> </li> <li> <code>compose</code>           \u2013            <p>Compose this route into a string.</p> </li> <li> <code>enter</code>           \u2013            <p>Enter a subroute.</p> </li> <li> <code>get</code>           \u2013            <p>Get an object at the end of this route.</p> </li> <li> <code>set</code>           \u2013            <p>Set an object pointed to by this route.</p> </li> <li> <code>__eq__</code>           \u2013            <p>Compare this route to another route.</p> </li> <li> <code>__str__</code>           \u2013            <p>Compose this route into a string.</p> </li> <li> <code>__iter__</code>           \u2013            <p>Yield all steps in this route.</p> </li> <li> <code>__repr__</code>           \u2013            <p>Represent this route in a string.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>steps</code>             (<code>list[Step[Any]]</code>)         \u2013          <p>Get all steps in this route.</p> </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def __init__(\n    self,\n    route: RouteLike,\n    *,\n    allow_empty: bool = False,\n) -&gt; None:\n    steps = self.parse(route)\n    if not (allow_empty or steps):\n        msg = \"Empty configuration route\"\n        raise ValueError(msg)\n    self.__steps = tuple(steps)\n</code></pre>"},{"location":"api/#configzen.routes.Route(route)","title":"<code>route</code>","text":"(<code>RouteLike</code>)         \u2013          <p>A route to parse.</p>"},{"location":"api/#configzen.routes.Route(allow_empty)","title":"<code>allow_empty</code>","text":"(<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to allow empty routes.</p>"},{"location":"api/#configzen.routes.Route.steps","title":"<code>steps: list[Step[Any]]</code>","text":"<p>Get all steps in this route.</p>"},{"location":"api/#configzen.routes.Route.__hash__","title":"<code>__hash__()</code>","text":"<p>Get a hash of this route.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Get a hash of this route.\"\"\"\n    return hash(self.__steps)\n</code></pre>"},{"location":"api/#configzen.routes.Route.parse","title":"<code>parse(route)</code>","text":"<p>Parse a route into steps.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>List of steps.</code>         \u2013          </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>@classmethod\ndef parse(cls, route: RouteLike) -&gt; list[Step[Any]]:\n    \"\"\"\n    Parse a route into steps.\n\n    Parameters\n    ----------\n    route\n        The route to parse.\n\n    Returns\n    -------\n    List of steps.\n\n    \"\"\"\n    if isinstance(route, Step):\n        return [route]\n    if isinstance(route, Route):\n        return route.steps\n    if isinstance(route, (tuple, list)):\n        patched_route: list[Step[Any]] = []\n        for element in route:\n            if isinstance(element, (str, int)):\n                try:\n                    patched_element = next(iter(cls.parse(element)))\n                except StopIteration:\n                    continue\n            else:\n                patched_element = element\n            patched_route.append(patched_element)\n        return patched_route\n    if isinstance(route, int):\n        return [GetItem(route)]\n    if isinstance(route, str):\n        return cls.decompose(route)\n    msg = f\"Invalid route type {type(route)!r}\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"api/#configzen.routes.Route.parse(route)","title":"<code>route</code>","text":"(<code>RouteLike</code>)         \u2013          <p>The route to parse.</p>"},{"location":"api/#configzen.routes.Route.decompose","title":"<code>decompose(route)</code>","text":"<p>Decompose a route into a list of steps.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>List of steps.</code>         \u2013          </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>@classmethod\ndef decompose(cls, route: str) -&gt; list[Step[Any]]:\n    \"\"\"\n    Decompose a route into a list of steps.\n\n    Parameters\n    ----------\n    route\n        A route to decompose.\n\n    Returns\n    -------\n    List of steps.\n\n    \"\"\"\n    if not route:\n        return []\n\n    dot, escape, enter, leave = cls.TOKENS\n\n    return _route_decompose(\n        route,\n        dot=dot,\n        escape=escape,\n        enter=enter,\n        leave=leave,\n    )\n</code></pre>"},{"location":"api/#configzen.routes.Route.decompose(route)","title":"<code>route</code>","text":"(<code>str</code>)         \u2013          <p>A route to decompose.</p>"},{"location":"api/#configzen.routes.Route.compose","title":"<code>compose()</code>","text":"<p>Compose this route into a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def compose(self) -&gt; str:\n    \"\"\"Compose this route into a string.\"\"\"\n    composed = \"\"\n    steps = self.__steps\n    for index, step in enumerate(steps):\n        composed += str(step)\n        if index &lt; len(steps) - 1:\n            ahead = steps[index + 1]\n            if isinstance(ahead, GetAttr):\n                composed += self.TOKEN_DOT\n    return composed\n</code></pre>"},{"location":"api/#configzen.routes.Route.enter","title":"<code>enter(subroute)</code>","text":"<p>Enter a subroute.</p> <p>Parameters:</p> Source code in <code>configzen/routes.py</code> <pre><code>def enter(self, subroute: RouteLike) -&gt; Route:\n    \"\"\"\n    Enter a subroute.\n\n    Parameters\n    ----------\n    subroute\n        A subroute to enter.\n\n    \"\"\"\n    return type(self)(self.steps + self.parse(subroute))\n</code></pre>"},{"location":"api/#configzen.routes.Route.enter(subroute)","title":"<code>subroute</code>","text":"(<code>RouteLike</code>)         \u2013          <p>A subroute to enter.</p>"},{"location":"api/#configzen.routes.Route.get","title":"<code>get(obj)</code>","text":"<p>Get an object at the end of this route.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>The result of visiting the object.</code>         \u2013          </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def get(self, obj: Any, /) -&gt; object:\n    \"\"\"\n    Get an object at the end of this route.\n\n    Parameters\n    ----------\n    obj\n        An object to dive in.\n\n    Returns\n    -------\n    The result of visiting the object.\n\n    \"\"\"\n    return reduce(lambda obj, step: step(obj), self.__steps, obj)\n</code></pre>"},{"location":"api/#configzen.routes.Route.get(obj)","title":"<code>obj</code>","text":"(<code>Any</code>)         \u2013          <p>An object to dive in.</p>"},{"location":"api/#configzen.routes.Route.set","title":"<code>set(obj, value)</code>","text":"<p>Set an object pointed to by this route.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>The result of visiting the object.</code>         \u2013          </li> </ul> Source code in <code>configzen/routes.py</code> <pre><code>def set(self, obj: Any, value: object, /) -&gt; None:\n    \"\"\"\n    Set an object pointed to by this route.\n\n    Parameters\n    ----------\n    obj\n        An object to dive in.\n\n    value\n        A value to set.\n\n    Returns\n    -------\n    The result of visiting the object.\n\n    \"\"\"\n    steps = self.steps\n    last_step = steps.pop()\n    last_step.set(\n        reduce(lambda obj, step: step(obj), steps, obj),\n        value,\n    )\n</code></pre>"},{"location":"api/#configzen.routes.Route.set(obj)","title":"<code>obj</code>","text":"(<code>Any</code>)         \u2013          <p>An object to dive in.</p>"},{"location":"api/#configzen.routes.Route.set(value)","title":"<code>value</code>","text":"(<code>object</code>)         \u2013          <p>A value to set.</p>"},{"location":"api/#configzen.routes.Route.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare this route to another route.</p> <p>Parameters:</p> Source code in <code>configzen/routes.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare this route to another route.\n\n    Parameters\n    ----------\n    other\n        Another route to compare to.\n\n    \"\"\"\n    if isinstance(other, Route):\n        return self.steps == other.steps\n    if isinstance(other, str):\n        return self.steps == self.decompose(other)\n    if isinstance(other, (tuple, list)):\n        return self.steps == self.parse(other)\n    return NotImplemented\n</code></pre>"},{"location":"api/#configzen.routes.Route.__eq__(other)","title":"<code>other</code>","text":"(<code>object</code>)         \u2013          <p>Another route to compare to.</p>"},{"location":"api/#configzen.routes.Route.__str__","title":"<code>__str__()</code>","text":"<p>Compose this route into a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Compose this route into a string.\"\"\"\n    return self.compose()\n</code></pre>"},{"location":"api/#configzen.routes.Route.__iter__","title":"<code>__iter__()</code>","text":"<p>Yield all steps in this route.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Step[Any]]:\n    \"\"\"Yield all steps in this route.\"\"\"\n    yield from self.__steps\n</code></pre>"},{"location":"api/#configzen.routes.Route.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent this route in a string.</p> Source code in <code>configzen/routes.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Represent this route in a string.\"\"\"\n    return f\"&lt;{type(self).__name__} {self.compose()!r}&gt;\"\n</code></pre>"},{"location":"api/#configzen.routes.advance_linked_route","title":"<code>advance_linked_route(_current_head, _annotation, _step)</code>","text":"<p>Move one step forward in a linked route.</p> Source code in <code>configzen/routes.py</code> <pre><code>@class_singledispatch\ndef advance_linked_route(\n    _current_head: Type[object],  # noqa: UP006\n    _annotation: Any,\n    _step: Step[object],\n) -&gt; Any:\n    \"\"\"Move one step forward in a linked route.\"\"\"\n    return _AnyHead\n</code></pre>"},{"location":"api/#configzen.sources","title":"<code>sources</code>","text":"<p>Sources and destinations that hold the configuration data.</p> <p>Classes:</p> <ul> <li> <code>ConfigSource</code>         \u2013          <p>Core interface for loading and saving configuration data.</p> </li> <li> <code>StreamConfigSource</code>         \u2013          <p>A configuration source that is a stream.</p> </li> <li> <code>FileConfigSource</code>         \u2013          <p>A configuration source that is a file.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_config_source</code>           \u2013            <p>Get a dedicated interface for a configuration source.</p> </li> <li> <code>get_stream_config_source</code>           \u2013            <p>Get a dedicated interface for a configuration source stream.</p> </li> <li> <code>get_file_config_source</code>           \u2013            <p>Get a dedicated interface for a configuration source file.</p> </li> </ul>"},{"location":"api/#configzen.sources.ConfigSource","title":"<code>ConfigSource(source, data_format=None, **options)</code>","text":"<p>             Bases: <code>Generic[SourceType, AnyStr]</code></p> <p>Core interface for loading and saving configuration data.</p> <p>If you need to implement your own configuration source class, implement a subclass of this class and pass in to the <code>.config_load()</code> method of your configuration or its model_config.</p> <p>Methods:</p> <ul> <li> <code>is_binary</code>           \u2013            <p>Determine whether the configuration source is binary.</p> </li> <li> <code>load</code>           \u2013            <p>Load the configuration source.</p> </li> <li> <code>load_async</code>           \u2013            <p>Load the configuration source asynchronously.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the configuration source.</p> </li> <li> <code>dump_async</code>           \u2013            <p>Dump the configuration source asynchronously.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data_format</code>             (<code>DataFormat[Any, AnyStr]</code>)         \u2013          <p>The current data format for a configuration source.</p> </li> </ul> Source code in <code>configzen/sources.py</code> <pre><code>def __init__(\n    self,\n    source: SourceType,\n    data_format: str | DataFormat[Any, AnyStr] | None = None,\n    **options: Unpack[FormatOptions],\n) -&gt; None:\n    self._temp_stream_factory: Callable[..., IO[AnyStr]] = (\n        self._binary_stream_factory\n        if self.is_binary()\n        else self._string_stream_factory\n    )\n    self.source = source\n    self.options = options\n    self.data_format = data_format  # type: ignore[assignment]\n</code></pre>"},{"location":"api/#configzen.sources.ConfigSource.data_format","title":"<code>data_format: DataFormat[Any, AnyStr]</code>","text":"<p>The current data format for a configuration source.</p>"},{"location":"api/#configzen.sources.ConfigSource.is_binary","title":"<code>is_binary()</code>","text":"<pre><code>is_binary() -&gt; Literal[False]\n</code></pre><pre><code>is_binary() -&gt; Literal[True]\n</code></pre> <p>Determine whether the configuration source is binary.</p> Source code in <code>configzen/sources.py</code> <pre><code>def is_binary(self: ConfigSource[SourceType, AnyStr]) -&gt; bool:\n    \"\"\"Determine whether the configuration source is binary.\"\"\"\n    return not type_check(self, ConfigSource[Any, str])\n</code></pre>"},{"location":"api/#configzen.sources.ConfigSource.load","title":"<code>load()</code>","text":"<p>Load the configuration source.</p> <p>Return its contents as a dictionary.</p> Source code in <code>configzen/sources.py</code> <pre><code>@abstractmethod\ndef load(self) -&gt; Data:\n    \"\"\"\n    Load the configuration source.\n\n    Return its contents as a dictionary.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.sources.ConfigSource.load_async","title":"<code>load_async()</code>","text":"<p>Load the configuration source asynchronously.</p> <p>Return its contents as a dictionary.</p> Source code in <code>configzen/sources.py</code> <pre><code>@abstractmethod\nasync def load_async(self) -&gt; Data:\n    \"\"\"\n    Load the configuration source asynchronously.\n\n    Return its contents as a dictionary.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.sources.ConfigSource.dump","title":"<code>dump(data)</code>","text":"<p>Dump the configuration source.</p> Source code in <code>configzen/sources.py</code> <pre><code>@abstractmethod\ndef dump(self, data: Data) -&gt; None:\n    \"\"\"Dump the configuration source.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.sources.ConfigSource.dump_async","title":"<code>dump_async(data)</code>","text":"<p>Dump the configuration source asynchronously.</p> Source code in <code>configzen/sources.py</code> <pre><code>@abstractmethod\nasync def dump_async(self, data: Data) -&gt; int:\n    \"\"\"Dump the configuration source asynchronously.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#configzen.sources.StreamConfigSource","title":"<code>StreamConfigSource(source, data_format, **options)</code>","text":"<p>             Bases: <code>Generic[AnyStr]</code>, <code>ConfigSource[IO[Any], Any]</code></p> <p>A configuration source that is a stream.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>load</code>           \u2013            <p>Load the configuration source.</p> </li> <li> <code>load_async</code>           \u2013            <p>Unsupported.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the configuration source.</p> </li> <li> <code>dump_async</code>           \u2013            <p>Unsupported.</p> </li> </ul> Source code in <code>configzen/sources.py</code> <pre><code>def __init__(\n    self,\n    source: IO[AnyStr],\n    data_format: str | DataFormat[Any, AnyStr],\n    **options: Unpack[FormatOptions],\n) -&gt; None:\n    super().__init__(source, data_format=data_format, **options)\n</code></pre>"},{"location":"api/#configzen.sources.StreamConfigSource(source)","title":"<code>source</code>","text":"(<code>IO[AnyStr]</code>)         \u2013          <p>The stream to the configuration source.</p>"},{"location":"api/#configzen.sources.StreamConfigSource.load","title":"<code>load()</code>","text":"<p>Load the configuration source.</p> <p>Return its contents as a dictionary.</p> Source code in <code>configzen/sources.py</code> <pre><code>def load(self) -&gt; Data:\n    \"\"\"\n    Load the configuration source.\n\n    Return its contents as a dictionary.\n    \"\"\"\n    return self.data_format.load(self.source)\n</code></pre>"},{"location":"api/#configzen.sources.StreamConfigSource.load_async","title":"<code>load_async()</code>","text":"<p>Unsupported.</p> Source code in <code>configzen/sources.py</code> <pre><code>def load_async(self) -&gt; Never:\n    \"\"\"Unsupported.\"\"\"\n    msg = \"async streams are not supported for `StreamConfigSource`\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#configzen.sources.StreamConfigSource.dump","title":"<code>dump(data)</code>","text":"<p>Dump the configuration source.</p> Source code in <code>configzen/sources.py</code> <pre><code>def dump(self, data: Data) -&gt; None:\n    \"\"\"Dump the configuration source.\"\"\"\n    self.data_format.dump(data, self.source)\n</code></pre>"},{"location":"api/#configzen.sources.StreamConfigSource.dump_async","title":"<code>dump_async(_data)</code>","text":"<p>Unsupported.</p> Source code in <code>configzen/sources.py</code> <pre><code>def dump_async(self, _data: Data) -&gt; Never:\n    \"\"\"Unsupported.\"\"\"\n    msg = \"async streams are not supported for `StreamConfigSource`\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource","title":"<code>FileConfigSource(source, data_format=None, *, use_processing_trace=True, **options)</code>","text":"<p>             Bases: <code>Generic[AnyStr]</code>, <code>ConfigSource[Path, AnyStr]</code></p> <p>A configuration source that is a file.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>load</code>           \u2013            <p>Load the configuration source file.</p> </li> <li> <code>load_async</code>           \u2013            <p>Load the configuration source file asynchronously.</p> </li> <li> <code>dump</code>           \u2013            <p>Dump the configuration data to the source file.</p> </li> <li> <code>dump_async</code>           \u2013            <p>Load the configuration source file asynchronously.</p> </li> <li> <code>read</code>           \u2013            <p>Read the configuration source and return its contents.</p> </li> <li> <code>read_async</code>           \u2013            <p>Read the configuration source file asynchronously and return its contents.</p> </li> <li> <code>write</code>           \u2013            <p>Write the configuration source file and return the number of bytes written.</p> </li> <li> <code>write_async</code>           \u2013            <p>Write the configuration source file asynchronously.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>paths</code>             (<code>list[Path]</code>)         \u2013          <p>List possible path variants basing on the processing context trace.</p> </li> </ul> Source code in <code>configzen/sources.py</code> <pre><code>def __init__(\n    self,\n    source: str | bytes | PathLike[str] | PathLike[bytes],\n    data_format: str | DataFormat[Any, Any] | None = None,\n    *,\n    use_processing_trace: bool = True,\n    **options: Unpack[FormatOptions],\n) -&gt; None:\n    super().__init__(_make_path(source), data_format=data_format, **options)\n    self._use_processing_trace = use_processing_trace\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource(source)","title":"<code>source</code>","text":"(<code>str | bytes | PathLike[str] | PathLike[bytes]</code>)         \u2013          <p>The path to the configuration source file.</p>"},{"location":"api/#configzen.sources.FileConfigSource.paths","title":"<code>paths: list[Path]</code>","text":"<p>List possible path variants basing on the processing context trace.</p>"},{"location":"api/#configzen.sources.FileConfigSource.load","title":"<code>load()</code>","text":"<p>Load the configuration source file.</p> <p>Return its contents as a dictionary.</p> Source code in <code>configzen/sources.py</code> <pre><code>def load(self) -&gt; Data:\n    \"\"\"\n    Load the configuration source file.\n\n    Return its contents as a dictionary.\n    \"\"\"\n    return self.data_format.load(self._temp_stream_factory(self.read()))\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.load_async","title":"<code>load_async()</code>","text":"<p>Load the configuration source file asynchronously.</p> <p>Return its contents as a dictionary.</p> Source code in <code>configzen/sources.py</code> <pre><code>async def load_async(self) -&gt; Data:\n    \"\"\"\n    Load the configuration source file asynchronously.\n\n    Return its contents as a dictionary.\n    \"\"\"\n    return self.data_format.load(self._temp_stream_factory(await self.read_async()))\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.dump","title":"<code>dump(data)</code>","text":"<p>Dump the configuration data to the source file.</p> <p>Parameters:</p> Source code in <code>configzen/sources.py</code> <pre><code>def dump(self, data: Data) -&gt; None:\n    \"\"\"\n    Dump the configuration data to the source file.\n\n    Parameters\n    ----------\n    data\n        The data to dump to the configuration source.\n\n                \"\"\"\n    temp_stream = self._temp_stream_factory()\n    self.data_format.dump(data, temp_stream)\n    temp_stream.seek(0)\n    self.write(temp_stream.read())\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.dump(data)","title":"<code>data</code>","text":"(<code>Data</code>)         \u2013          <p>The data to dump to the configuration source.</p>"},{"location":"api/#configzen.sources.FileConfigSource.dump_async","title":"<code>dump_async(data)</code>","text":"<p>Load the configuration source file asynchronously.</p> <p>Return its contents as a dictionary.</p> <p>Parameters:</p> Source code in <code>configzen/sources.py</code> <pre><code>async def dump_async(self, data: Data) -&gt; int:\n    \"\"\"\n    Load the configuration source file asynchronously.\n\n    Return its contents as a dictionary.\n\n    Parameters\n    ----------\n    data\n        The data to dump to the configuration source.\n\n                \"\"\"\n    temp_stream = self._temp_stream_factory()\n    self.data_format.dump(data, temp_stream)\n    temp_stream.seek(0)\n    return await self.write_async(temp_stream.read())\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.dump_async(data)","title":"<code>data</code>","text":"(<code>Data</code>)         \u2013          <p>The data to dump to the configuration source.</p>"},{"location":"api/#configzen.sources.FileConfigSource.read","title":"<code>read()</code>","text":"<p>Read the configuration source and return its contents.</p> Source code in <code>configzen/sources.py</code> <pre><code>def read(self) -&gt; AnyStr:\n    \"\"\"Read the configuration source and return its contents.\"\"\"\n    errors = []\n    reader = Path.read_bytes if self.is_binary() else Path.read_text\n    for path in self.paths:\n        try:\n            return reader(path)\n        except FileNotFoundError as e:  # noqa: PERF203\n            errors.append(e)\n            continue\n    raise FileNotFoundError(errors)\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.read_async","title":"<code>read_async()</code>","text":"<p>Read the configuration source file asynchronously and return its contents.</p> Source code in <code>configzen/sources.py</code> <pre><code>async def read_async(self) -&gt; AnyStr:\n    \"\"\"Read the configuration source file asynchronously and return its contents.\"\"\"\n    errors = []\n    reader = AsyncPath.read_bytes if self.is_binary() else AsyncPath.read_text\n    for path in map(AsyncPath, self.paths):\n        try:\n            return await reader(path)\n        except FileNotFoundError as e:  # noqa: PERF203\n            errors.append(e)\n            continue\n    raise FileNotFoundError(errors)\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.write","title":"<code>write(content)</code>","text":"<p>Write the configuration source file and return the number of bytes written.</p> <p>Parameters:</p> Source code in <code>configzen/sources.py</code> <pre><code>def write(self, content: AnyStr) -&gt; int:\n    \"\"\"\n    Write the configuration source file and return the number of bytes written.\n\n    Parameters\n    ----------\n    content\n        The content to write to the configuration source.\n\n    \"\"\"\n    if self.is_binary():\n        return self.source.write_bytes(content)\n    return self.source.write_text(content)\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.write(content)","title":"<code>content</code>","text":"(<code>AnyStr</code>)         \u2013          <p>The content to write to the configuration source.</p>"},{"location":"api/#configzen.sources.FileConfigSource.write_async","title":"<code>write_async(content)</code>","text":"<p>Write the configuration source file asynchronously.</p> <p>Return the number of bytes written.</p> <p>Parameters:</p> Source code in <code>configzen/sources.py</code> <pre><code>async def write_async(self, content: AnyStr) -&gt; int:\n    \"\"\"\n    Write the configuration source file asynchronously.\n\n    Return the number of bytes written.\n\n    Parameters\n    ----------\n    content\n        The content to write to the configuration source.\n\n    \"\"\"\n    if self.is_binary():\n        return await AsyncPath(self.source).write_bytes(content)\n    return await AsyncPath(self.source).write_text(content)\n</code></pre>"},{"location":"api/#configzen.sources.FileConfigSource.write_async(content)","title":"<code>content</code>","text":"(<code>AnyStr</code>)         \u2013          <p>The content to write to the configuration source.</p>"},{"location":"api/#configzen.sources.get_config_source","title":"<code>get_config_source(source, _data_format=None)</code>","text":"<p>Get a dedicated interface for a configuration source.</p> Source code in <code>configzen/sources.py</code> <pre><code>@singledispatch\ndef get_config_source(\n    source: object,\n    _data_format: DataFormat[Any, AnyStr] | None = None,\n) -&gt; ConfigSource[Any, Any]:\n    \"\"\"Get a dedicated interface for a configuration source.\"\"\"\n    type_name = type(source).__name__\n    msg = (\n        f\"There is no class operating on {type_name!r} configuration \"\n        f\"sources. Implement it by creating a subclass of ConfigSource.\"\n    )\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#configzen.sources.get_stream_config_source","title":"<code>get_stream_config_source(source, data_format)</code>","text":"<p>Get a dedicated interface for a configuration source stream.</p> Source code in <code>configzen/sources.py</code> <pre><code>@get_config_source.register(BytesIO)\n@get_config_source.register(StringIO)\ndef get_stream_config_source(\n    source: IO[bytes] | IO[str],\n    data_format: DataFormat[Any, Any],\n) -&gt; StreamConfigSource[str] | StreamConfigSource[bytes]:\n    \"\"\"Get a dedicated interface for a configuration source stream.\"\"\"\n    return StreamConfigSource(source, data_format=data_format)\n</code></pre>"},{"location":"api/#configzen.sources.get_file_config_source","title":"<code>get_file_config_source(source, data_format=None)</code>","text":"<p>Get a dedicated interface for a configuration source file.</p> Source code in <code>configzen/sources.py</code> <pre><code>@get_config_source.register(str)\n@get_config_source.register(bytes)\n@get_config_source.register(PathLike)\ndef get_file_config_source(\n    source: str | bytes | PathLike[str] | PathLike[bytes],\n    data_format: DataFormat[Any, AnyStr] | None = None,\n) -&gt; FileConfigSource[str] | FileConfigSource[bytes]:\n    \"\"\"Get a dedicated interface for a configuration source file.\"\"\"\n    return FileConfigSource(source, data_format=data_format)\n</code></pre>"},{"location":"api/#configzen.typedefs","title":"<code>typedefs</code>","text":"<p>Miscellaneous type definitions for configzen.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog. This project adheres to Semantic Versioning.</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at bartoszpiotrslawecki@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-configzen","title":"Contributing to configzen \ud83c\udf89","text":"<p>Contributions are very welcome. \ud83d\ude80</p> <p>There are many ways to contribute, ranging from writing tutorials and improving the documentation, to submitting bug reports and feature requests or writing code which can be incorporated into configzen.</p>"},{"location":"contributing/#report-bugs-and-request-features","title":"Report bugs and request features \ud83d\udc1b","text":"<p>Report these in the issue tracker. Relevant forms provide guidance on how to write a good bug report or feature request.</p>"},{"location":"contributing/#implement-new-features","title":"Implement new features \u2b50","text":"<p>Look here. Anything tagged with \"enhancement\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write documentation \ud83d\udcd6","text":"<p>The project could always use more documentation, whether as part of the official project docs. If you're interested in helping out, check the docs/ folder in the repository.</p>"},{"location":"contributing/#share-your-feedback","title":"Share your feedback \ud83c\udf0d","text":"<p>The best way to send feedback is to file an issue in the issue tracker.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are     welcome! \u2728</li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request guidelines \ud83d\udcdd","text":"<ol> <li> <p>Initially mark the PR as a draft, so that the maintainers know that you are making final touches.</p> </li> <li> <p>Ensure that the test coverage is not decreased. If you add a new feature, please add tests for it. Read more about coverage.</p> </li> <li> <p>Ensure that all GitHub checks pass. If they are disabled in your PR, ping the maintainers to request enabling them.</p> </li> <li> <p>Don't forget to link the relevant issue(s) in the PR description and describe the changes you made.</p> </li> </ol>"},{"location":"contributing/#get-started","title":"Get started! \ud83d\udd79\ufe0f","text":"<p>Ready to contribute? Here's a quick guide on how to set up configzen and make a change.</p> <p>Note</p> <p>If you use Windows, it is highly recommended to complete the installation in the way presented below through WSL2.</p> <ol> <li> <p>Fork the configzen repository on GitHub.</p> </li> <li> <p>Install Poetry.     Poetry is an amazing tool for managing dependencies &amp; virtual environments, building packages and publishing them.     You might use pipx to install it globally (recommended):</p> <pre><code>pipx install poetry\n</code></pre> <p><sub>If you encounter any problems, refer to the official documentation for the most up-to-date installation instructions.</sub></p> <p>Be sure to have Python 3.8 installed\u2014if you use pyenv, simply run:</p> <pre><code>pyenv install 3.8\n</code></pre> </li> <li> <p>Clone your fork locally and install dependencies.</p> <pre><code>git clone https://github.com/your-username/configzen path/to/configzen\ncd path/to/configzen\npoetry env use $(cat .python-version)\npoetry install\n</code></pre> <p>Next up, simply activate the virtual environment and install pre-commit hooks:</p> <pre><code>poetry shell\npre-commit install\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass all tests:</p> <pre><code>poe check\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add -A\ngit commit -m \"Short description of changes (50 chars max)\" -m \"Optional extended description\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"}]}